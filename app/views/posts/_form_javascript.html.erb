<script nonce="<%= content_security_policy_nonce %>">
    // Global variables
    window.selectedFiles = window.selectedFiles || [];

    function initPostForm() {
        // Initialize form functionality
        initializeFormFeatures();
        initializeUploadHandlers();
        initializeAutoSave();
        initializeFormValidation();
    }

    function initPostFormOnce() {
        if (window._postFormInitOnce) return;
        window._postFormInitOnce = true;
        initPostForm();
    }

    document.addEventListener('DOMContentLoaded', initPostFormOnce);
    document.addEventListener('turbo:load', initPostFormOnce);
    document.addEventListener('turbo:render', initPostFormOnce);
    if (document.readyState !== 'loading') { initPostFormOnce(); }

    // Form features initialization
    function initializeFormFeatures() {
        // Post type and category management
        initializePostTypeManagement();
        initializeCategoryManagement();

        // File upload UI
        initializeFileUploadUI();

        // Content editing features
        initializeContentEditor();

        initializeUpdateProgressModal();
    }

    // Upload handlers
    function initializeUploadHandlers() {
        const imageInput = document.getElementById('imageInput');
        const videoInput = document.getElementById('videoInput');
        const textarea = document.getElementById('contentTextarea');

        const codeEditorElement = textarea?.closest('[data-controller*="code-editor"]');

        // イベントリスナーの活用: キューイングシステムの実装
        if (codeEditorElement) {
            // テキスト挿入キューの初期化
            if (!codeEditorElement._insertQueue) {
                codeEditorElement._insertQueue = [];
            }

            codeEditorElement.addEventListener('code-editor:initialized', () => {
                console.log('CodeEditor is ready for image insertions');

                // キューに溜まったテキスト挿入要求を処理
                if (codeEditorElement._insertQueue && codeEditorElement._insertQueue.length > 0) {
                    console.log(`Processing ${codeEditorElement._insertQueue.length} queued text insertions`);

                    codeEditorElement._insertQueue.forEach((queuedText, index) => {
                        setTimeout(() => {
                            const textarea = document.getElementById('contentTextarea');
                            if (textarea) {
                                insertMarkdownAtCursor(textarea, queuedText);
                            }
                        }, index * 100); // 各挿入を100ms間隔で実行
                    });

                    // キューをクリア
                    codeEditorElement._insertQueue = [];
                }
            });
        }

        if (imageInput) {
            imageInput.addEventListener('change', handleImageUpload);
            // direct-uploadイベントリスナーを削除（即座にアップロードしないため）
        }

        if (videoInput) {
            videoInput.addEventListener('change', handleVideoUpload);
            // direct-uploadイベントリスナーを削除（即座にアップロードしないため）
        }
    }

    // Auto-save functionality
    function initializeAutoSave() {
        console.log('Auto-save initialization started');

        // 新規作成または編集の場合のみ自動保存を有効にする
        const form = document.querySelector('form[data-turbo="false"]');
        const currentPath = window.location.pathname;
        const isNewOrEdit = form && (currentPath.includes('/new') || currentPath.includes('/edit'));

        console.log('Auto-save debug info:', {
            form: !!form,
            currentPath: currentPath,
            isNewOrEdit: isNewOrEdit
        });

        if (isNewOrEdit) {
            window.autoSaveEnabled = true;
            window.autoSaveInterval = setInterval(performAutoSave, 5000);
            console.log('Auto-save enabled with 5-second interval');

            // フォーム送信時に自動保存を停止
            if (form) {
                form.addEventListener('submit', function (event) {
                    console.log('Form submit detected, stopping auto-save');
                    stopAutoSave();
                });
            }
        } else {
            console.log('Auto-save not initialized - conditions not met');
        }
    }

    function stopAutoSave() {
        console.log('Stopping auto-save...');
        window.autoSaveEnabled = false;
        if (window.autoSaveInterval) {
            clearInterval(window.autoSaveInterval);
            window.autoSaveInterval = null;
        }
    }

    // Form validation
    function initializeFormValidation() {
        const form = document.querySelector('.needs-validation');
        if (form) {
            form.addEventListener('submit', function (event) {
                event.preventDefault();
                event.stopPropagation();

                // Custom ordered validation
                const validationResult = performOrderedValidation();

                if (validationResult.isValid) {
                    // Remove validation classes and proceed with submission
                    form.classList.remove('was-validated');
                    clearValidationErrors();

                    // Allow form submission
                    event.target.removeEventListener('submit', arguments.callee);
                    event.target.submit();
                } else {
                    // Show the first error in order
                    showValidationError(validationResult.firstError);
                    form.classList.add('was-validated');
                }
            });
        }
    }

    // Perform ordered validation as specified in the issue
    function performOrderedValidation() {
        const validationOrder = [
            {
                field: 'purpose',
                selector: 'textarea[name="post[purpose]"]',
                message: '必須項目を入力または選択してください',
                label: '投稿の目的'
            },
            {
                field: 'post_type_id',
                selector: 'select[name="post[post_type_id]"]',
                message: '必須項目を入力または選択してください',
                label: '投稿タイプ'
            },
            {
                field: 'category_id',
                selector: 'select[name="post[category_id]"]',
                message: '必須項目を入力または選択してください',
                label: 'カテゴリー'
            },
            {
                field: 'target_audience',
                selector: 'input[name="post[target_audience]"]',
                message: '必須項目を入力または選択してください',
                label: '対象読者'
            },
            {
                field: 'title',
                selector: 'input[name="post[title]"]',
                message: '必須項目を入力または選択してください',
                label: 'タイトル'
            }
        ];

        for (let i = 0; i < validationOrder.length; i++) {
            const validation = validationOrder[i];
            const element = document.querySelector(validation.selector);

            if (!element) {
                console.warn(`Element not found for ${validation.field}: ${validation.selector}`);
                continue;
            }

            let isEmpty = false;

            if (element.tagName === 'SELECT') {
                isEmpty = !element.value || element.value === '';
            } else {
                isEmpty = !element.value || element.value.trim() === '';
            }

            if (isEmpty) {
                return {
                    isValid: false,
                    firstError: {
                        element: element,
                        message: validation.message,
                        label: validation.label,
                        field: validation.field
                    }
                };
            }
        }

        return {isValid: true};
    }

    // Show validation error for the first missing required field
    function showValidationError(error) {
        // Clear previous validation errors
        clearValidationErrors();

        // Add invalid class to the problematic field
        error.element.classList.add('is-invalid');

        // Find or create error message element
        let errorDiv = error.element.parentNode.querySelector('.invalid-feedback');
        if (!errorDiv) {
            errorDiv = document.createElement('div');
            errorDiv.className = 'invalid-feedback';
            error.element.parentNode.appendChild(errorDiv);
        }

        errorDiv.textContent = error.message;
        errorDiv.style.display = 'block';

        // Scroll to the problematic field
        error.element.scrollIntoView({
            behavior: 'smooth',
            block: 'center'
        });

        // Focus on the field
        setTimeout(() => {
            error.element.focus();
        }, 300);

        // Show alert with generic message
        showAlert('必須項目を入力または選択してください', 'danger');
    }

    // Clear all validation errors
    function clearValidationErrors() {
        const invalidElements = document.querySelectorAll('.is-invalid');
        invalidElements.forEach(element => {
            element.classList.remove('is-invalid');
        });

        const errorDivs = document.querySelectorAll('.invalid-feedback');
        errorDivs.forEach(div => {
            div.style.display = 'none';
        });
    }

    // Post type management
    function initializePostTypeManagement() {
        const addBtn = document.getElementById('addPostTypeBtn');
        const saveBtn = document.getElementById('savePostTypeBtn');
        const cancelBtn = document.getElementById('cancelPostTypeBtn');
        const form = document.getElementById('newPostTypeForm');

        if (addBtn) {
            addBtn.addEventListener('click', () => toggleForm(form, true));
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => toggleForm(form, false));
        }

        if (saveBtn) {
            saveBtn.addEventListener('click', saveNewPostType);
        }
    }

    // Category management
    function initializeCategoryManagement() {
        const addBtn = document.getElementById('addCategoryBtn');
        const saveBtn = document.getElementById('saveCategoryBtn');
        const cancelBtn = document.getElementById('cancelCategoryBtn');
        const form = document.getElementById('newCategoryForm');

        if (addBtn) {
            addBtn.addEventListener('click', () => toggleForm(form, true));
        }

        if (cancelBtn) {
            cancelBtn.addEventListener('click', () => toggleForm(form, false));
        }

        if (saveBtn) {
            saveBtn.addEventListener('click', saveNewCategory);
        }
    }

    // File upload UI
    function initializeFileUploadUI() {
        // Image and video deletion buttons
        document.addEventListener('click', function (e) {
            if (e.target.closest('.delete-image-btn')) {
                handleImageDelete(e);
            }

            if (e.target.closest('.delete-video-btn')) {
                handleVideoDelete(e);
            }

            if (e.target.closest('.insert-existing-image')) {
                insertExistingMedia(e, 'image');
            }

            if (e.target.closest('.insert-existing-video')) {
                insertExistingMedia(e, 'video');
            }
        });
    }

    // Content editor features
    function initializeContentEditor() {
        const textarea = document.getElementById('contentTextarea');
        if (!textarea) return;

        // 本番環境での確実な初期化確認
        const checkCodeEditor = () => {
            const codeEditorElement = textarea.closest('[data-controller*="code-editor"]');
            if (codeEditorElement && codeEditorElement.classList.contains('codemirror-initialized')) {
                console.log('CodeEditorは正常に初期化済み');
                return true;
            }
            return false;
        };

        // 初期チェック
        if (checkCodeEditor()) {
            return;
        }

        // 本番環境用：より長い待機時間でフォールバック（CM6/Stimulus を再接続試行）
        setTimeout(() => {
            if (!checkCodeEditor()) {
                console.warn('Stimulusコントローラー初期化失敗。手動初期化を実行...');
                forceInitializeCodeEditorFallbackProduction(textarea);
            }
        }, 5000); // 本番環境用に5秒に延長
    }

    // 本番環境専用のフォールバック初期化（CM6/Stimulus 再接続用）
    async function forceInitializeCodeEditorFallbackProduction(textarea) {
        try {
            console.log('フォールバック初期化開始...');

            const wrapper = textarea.closest('[data-controller*="code-editor"]');
            if (!wrapper) {
                console.error('code-editor コントローラー要素が見つかりません');
                return;
            }

            // Stimulus 再接続のために data-controller 属性を一旦外して付け直す
            const original = wrapper.getAttribute('data-controller') || '';
            wrapper.removeAttribute('data-controller');
            // Reflow を発生させて確実に属性変化を通知
            void wrapper.offsetHeight;
            wrapper.setAttribute('data-controller', original);

            // 再接続後、codemirror-initialized が付くのを待機
            let attempts = 0;
            const maxAttempts = 40; // 500ms * 40 = 20s まで待機
            while (attempts < maxAttempts) {
                await new Promise(resolve => setTimeout(resolve, 500));
                if (wrapper.classList.contains('codemirror-initialized')) {
                    console.log('✅ Stimulus再接続によりCodeMirror6が初期化されました');
                    return;
                }
                attempts++;
            }

            console.error('CodeMirror6の初期化を確認できませんでした');
        } catch (error) {
            console.error('フォールバック初期化失敗:', error);
        }
    }

    // forceInitializeCodeEditorFallback関数（200行目付近）の改善
    async function forceInitializeCodeEditorFallback(textarea) {
        try {
            // 本番環境での確実な読み込み確認
            let CodeMirror = window.CodeMirror;

            if (!CodeMirror && window.loadCodeMirror) {
                console.log('Loading CodeMirror via loadCodeMirror function...');
                CodeMirror = await window.loadCodeMirror();
            }

            // 追加の待機処理（本番環境での遅延対応）
            if (!CodeMirror || typeof CodeMirror.fromTextArea !== 'function') {
                console.log('Waiting for CodeMirror in production...');
                let attempts = 0;
                while (attempts < 20 && (!window.CodeMirror || typeof window.CodeMirror.fromTextArea !== 'function')) {
                    await new Promise(resolve => setTimeout(resolve, 500));
                    attempts++;
                    console.log(`CodeMirror wait attempt: ${attempts}`);
                }
                CodeMirror = window.CodeMirror;
            }

            if (CodeMirror && typeof CodeMirror.fromTextArea === 'function') {
                const editor = CodeMirror.fromTextArea(textarea, {
                    mode: 'markdown',
                    theme: 'default',
                    lineNumbers: true,
                    lineWrapping: true,
                    indentUnit: 2,
                    tabSize: 2
                });
                console.log('✓ フォールバックでCodeEditorを初期化しました');
            } else {
                console.error('CodeMirror could not be loaded in production');
            }
        } catch (error) {
            console.error('フォールバック初期化にも失敗:', error);
        }
    }

    // Helper functions
    function toggleForm(form, show) {
        if (form) {
            form.style.display = show ? 'block' : 'none';
        }
    }

    function handleImageUpload(event) {
        const files = Array.from(event.target.files);
        const textarea = document.getElementById('contentTextarea');
        const codeEditorElement = textarea?.closest('[data-controller*="code-editor"]');

        // 新しいファイルを既存の選択に追加
        const newFiles = files.filter(newFile =>
            !window.selectedFiles.some(existingFile => existingFile.name === newFile.name)
        );
        window.selectedFiles = window.selectedFiles.concat(newFiles);

        displaySelectedFiles(window.selectedFiles);

        const imageInput = document.getElementById('imageInput');
        if (imageInput) {
            const dt = new DataTransfer();
            window.selectedFiles.forEach(file => dt.items.add(file));
            imageInput.files = dt.files;
        }

        for (let file of newFiles) {
            console.log('Image selected:', file.name);

            if (textarea) {
                const markdownLink = `![${file.name}](attachment:${file.name})\n\n`;

                // CodeEditorの初期化を確認
                if (codeEditorElement && codeEditorElement.classList.contains('codemirror-initialized')) {
                    insertMarkdownAtCursor(textarea, markdownLink);
                } else {
                    // 初期化完了を待つ
                    codeEditorElement.addEventListener('code-editor:initialized', () => {
                        insertMarkdownAtCursor(textarea, markdownLink);
                    }, {once: true});

                    // タイムアウトとして1秒後にも実行
                    setTimeout(() => {
                        insertMarkdownAtCursor(textarea, markdownLink);
                    }, 1000);
                }
            }
        }
    }

    function handleVideoUpload(event) {
        const file = event.target.files[0];
        const textarea = document.getElementById('contentTextarea');

        if (file) {
            console.log('Video selected:', file.name);

            // Insert Markdown format link into content textarea
            if (textarea) {
                const markdownLink = `[${file.name}](attachment:${file.name})\n\n`;
                // CodeMirrorの初期化を少し待つ
                setTimeout(() => {
                    insertMarkdownAtCursor(textarea, markdownLink);
                }, 1000);
            }
        }
    }

    function handleDirectUploadStart(event) {
        showUploadProgress();
        updateUploadStatus('アップロード開始中...', 0);
    }

    function handleDirectUploadEnd(event) {
        updateUploadStatus('アップロード完了', 100);
        setTimeout(hideUploadProgress, 2000);
    }

    function handleDirectUploadError(event) {
        updateUploadStatus('アップロードエラー', 0);
        showError('ファイルのアップロードに失敗しました。');
    }

    function showUploadProgress() {
        const container = document.getElementById('uploadProgressContainer');
        if (container) {
            container.style.display = 'block';
        }
    }

    function hideUploadProgress() {
        const container = document.getElementById('uploadProgressContainer');
        if (container) {
            container.style.display = 'none';
        }
    }

    function updateUploadStatus(text, progress) {
        const statusText = document.getElementById('uploadStatusText');
        const progressBar = document.getElementById('uploadProgressBar');

        if (statusText) statusText.textContent = text;
        if (progressBar) {
            progressBar.style.width = progress + '%';
            progressBar.setAttribute('aria-valuenow', progress);
        }
    }

    function performAutoSave() {
        // 自動保存が有効かチェック
        if (!window.autoSaveEnabled) {
            return;
        }

        // Auto-save implementation
        const form = document.querySelector('form[data-turbo="false"]');
        if (!form) {
            return;
        }

        // 画像ファイルを除外したFormDataを作成
        const formData = new FormData();

        // 必須パラメータを確実に設定
        const postIdInput = document.getElementById('post_id');
        if (postIdInput && postIdInput.value) {
            formData.append('post_id', postIdInput.value);
        }

        // テキストフィールドのみを取得
        const formElements = form.elements;
        let fieldCount = 0;

        for (let i = 0; i < formElements.length; i++) {
            const element = formElements[i];

            // ファイルフィールドは除外
            if (element.type === 'file') {
                continue;
            }

            // その他のフィールドは追加（post_idは既に追加済みなのでスキップ）
            // その他のフィールドは追加（post_idと_methodは除外）
            if (element.name && element.value !== undefined &&
                element.name !== 'post_id' && element.name !== '_method') {
                if (element.type === 'checkbox' || element.type === 'radio') {
                    if (element.checked) {
                        formData.append(element.name, element.value);
                        fieldCount++;
                    }
                } else if (element.type !== 'submit' && element.type !== 'button') {
                    // 空の値でも送信（サーバーサイドで処理）
                    formData.append(element.name, element.value);
                    fieldCount++;
                }
            }
        }

        console.log(`Auto-save: ${fieldCount} fields prepared for submission`);

        fetch('/posts/auto_save', {
            method: 'POST',
            headers: {
                'X-Requested-With': 'XMLHttpRequest',
                'X-CSRF-Token': getCSRFToken(),
                'Accept': 'application/json'
            },
            body: formData
        })
            .then(response => {
                const contentType = response.headers.get('content-type');

                if (!response.ok) {
                    return response.text().then(text => {
                        console.error('Auto-save: Server error response:', text);
                        throw new Error(`Server error: ${response.status} - ${text.substring(0, 200)}`);
                    });
                }

                if (contentType && contentType.includes('application/json')) {
                    return response.json();
                } else {
                    return response.text().then(text => {
                        console.error('Auto-save: Invalid response format, received:', text.substring(0, 500));
                        console.error('Auto-save: Expected JSON, got Content-Type:', contentType);
                        throw new Error(`Invalid response format. Expected JSON, got: ${contentType}`);
                    });
                }
            })
            .then(data => {
                console.log('Auto-save response data:', data);
                if (data && data.success) {
                    showAutoSaveSuccess(data.message);
                    updatePostId(data.post_id);
                    console.log('Auto-save completed successfully');
                } else {
                    console.warn('Auto-save failed:', data?.message || 'Unknown error');
                }
            })
            .catch(error => {
                console.error('Auto-save error details:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });
                // 開発時のみエラーメッセージを表示
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    showAutoSaveError(`自動保存エラー: ${error.message}`);
                }
            });
    }

    function showAutoSaveError(message) {
        const alert = document.getElementById('autoSaveAlert');
        const messageSpan = document.getElementById('autoSaveMessage');

        if (alert && messageSpan) {
            messageSpan.textContent = message;
            alert.className = 'alert alert-danger alert-dismissible fade show'; // エラー用スタイル
            alert.style.display = 'block';

            setTimeout(() => {
                alert.classList.remove('show');
                setTimeout(() => {
                    alert.style.display = 'none';
                    alert.className = 'alert alert-success alert-dismissible fade'; // 元に戻す
                }, 300);
            }, 8000); // エラーは少し長めに表示
        }
    }

    function showAutoSaveSuccess(message) {
        const alert = document.getElementById('autoSaveAlert');
        const messageSpan = document.getElementById('autoSaveMessage');

        if (alert && messageSpan) {
            messageSpan.textContent = message + ' ' + new Date().toLocaleTimeString();
            alert.className = 'alert alert-success alert-dismissible fade show';
            alert.style.display = 'block';

            setTimeout(() => {
                alert.classList.remove('show');
                setTimeout(() => {
                    alert.style.display = 'none';
                }, 300);
            }, 3000);
        }
    }

    function updatePostId(postId) {
        const hiddenInput = document.getElementById('post_id');
        if (hiddenInput && postId) {
            hiddenInput.value = postId;
        }
    }

    function getCSRFToken() {
        const token = document.querySelector('meta[name="csrf-token"]');
        return token ? token.getAttribute('content') : '';
    }

    function saveNewPostType() {
        // Implementation for saving new post type
    }

    function saveNewCategory() {
        // Implementation for saving new category
    }

    function handleImageDelete(event) {
        const button = event.target.closest('.delete-image-btn');
        if (!button) return;

        const postId = button.dataset.postId;
        const attachmentId = button.dataset.attachmentId;
        const filename = button.dataset.filename;

        if (!confirm(`画像「${filename}」を削除しますか？`)) {
            return;
        }

        fetch(`/posts/${postId}/delete_image`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': getCSRFToken(),
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({attachment_id: attachmentId})
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove the image card from DOM
                    const imageCard = document.getElementById(`image-card-${attachmentId}`);
                    if (imageCard) {
                        imageCard.remove();
                    }
                    showSuccess(data.message);
                } else {
                    showError(data.message || '画像の削除に失敗しました');
                }
            })
            .catch(error => {
                console.error('Delete error:', error);
                showError('画像の削除中にエラーが発生しました');
            });
    }

    function handleVideoDelete(event) {
        console.log('Delete button clicked'); // デバッグ用
        const button = event.target.closest('.delete-video-btn');
        console.log('Button found:', button); // デバッグ用
        if (!button) return;

        const postId = button.dataset.postId;
        const attachmentId = button.dataset.attachmentId;
        const filename = button.dataset.filename;

        if (!confirm(`動画「${filename}」を削除しますか？`)) {
            return;
        }

        fetch(`/posts/${postId}/delete_video`, {
            method: 'DELETE',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRF-Token': getCSRFToken(),
                'X-Requested-With': 'XMLHttpRequest'
            },
            body: JSON.stringify({attachment_id: attachmentId})
        })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Remove the video card from DOM
                    const videoCard = document.getElementById(`video-card-${attachmentId}`);
                    if (videoCard) {
                        videoCard.remove();
                    }
                    showSuccess(data.message);
                } else {
                    showError(data.message || '動画の削除に失敗しました');
                }
            })
            .catch(error => {
                console.error('Delete error:', error);
                showError('動画の削除中にエラーが発生しました');
            });
    }

    function insertExistingMedia(event, type) {
        const button = event.target.closest('.insert-existing-image, .insert-existing-video');
        if (!button) return;

        const filename = button.dataset.filename;
        const url = button.dataset.url;
        const textarea = document.getElementById('contentTextarea');

        if (!textarea || !filename) return;

        let markdownLink;
        if (type === 'image' || button.classList.contains('insert-existing-image')) {
            markdownLink = `![${filename}](${url})\n\n`;
        } else {
            markdownLink = `[${filename}](${url})\n\n`;
        }

        insertMarkdownAtCursor(textarea, markdownLink);
        showSuccess(`${type === 'image' ? '画像' : '動画'}「${filename}」を挿入しました`);
    }

    function addMarkdownShortcuts(textarea) {
        // Implementation for markdown shortcuts
        console.log('Add markdown shortcuts to textarea');
    }

    function insertMarkdownAtCursor(textarea, text) {
        if (!textarea) return;

        console.log('insertMarkdownAtCursor called with text:', text);

        const codeEditorElement = textarea.closest('[data-controller*="code-editor"]');
        if (codeEditorElement) {
            console.log('Found code-editor element:', codeEditorElement);

            // 新しい方法: カスタムイベントを使用した確実な挿入
            const insertEvent = new CustomEvent('code-editor:insert-text', {
                detail: {text: text},
                bubbles: true
            });

            // まずイベントベースの挿入を試行
            codeEditorElement.dispatchEvent(insertEvent);

            // 少し待ってから成功確認
            setTimeout(() => {
                verifyTextInsertion(textarea, text, codeEditorElement);
            }, 100);

            return; // イベントベース処理で完了
        }

        // フォールバック: 通常のテキストエリア処理
        performFallbackInsertion(textarea, text);
    }

    function performFallbackInsertion(textarea, text) {
        console.log('Performing enhanced fallback text insertion');

        try {
            // 1. CodeMirrorエディターへの直接アクセス
            const cmEditor = textarea.parentNode.querySelector('.cm-editor');
            if (cmEditor) {
                // CodeMirror 6のDOM要素から逆引きでエディターインスタンスを取得
                const editorView = cmEditor.cmView || window.cmEditors?.get?.(cmEditor);
                if (editorView && editorView.state) {
                    console.log('Using direct CodeMirror 6 DOM access');
                    const cursor = editorView.state.selection.main.head;
                    const transaction = editorView.state.update({
                        changes: {from: cursor, insert: text}
                    });
                    editorView.dispatch(transaction);
                    editorView.focus();
                    return;
                }
            }

            // 2. 通常のテキストエリア処理
            const start = textarea.selectionStart ?? textarea.value.length;
            const end = textarea.selectionEnd ?? textarea.value.length;
            const before = textarea.value.substring(0, start);
            const after = textarea.value.substring(end);

            textarea.value = before + text + after;
            const newPos = start + text.length;
            textarea.selectionStart = textarea.selectionEnd = newPos;
            textarea.focus();
            textarea.dispatchEvent(new Event('input', {bubbles: true}));

            console.log('Fallback text insertion completed successfully');

        } catch (error) {
            console.error('Fallback insertion failed:', error);
        }
    }

    function verifyTextInsertion(textarea, text, codeEditorElement) {
        // CodeMirrorエディターの値を確認
        let currentValue = '';

        // CodeMirror 6からの値取得を試行
        const controller = getCodeEditorController(codeEditorElement);
        if (controller && controller.editor) {
            currentValue = controller.editor.state.doc.toString();
        } else {
            currentValue = textarea.value;
        }

        // テキストが挿入されているかチェック
        if (!currentValue.includes(text.trim())) {
            console.log('Text insertion verification failed, using fallback');
            performFallbackInsertion(textarea, text);
        } else {
            console.log('Text insertion verified successfully');
        }
    }

    function getCodeEditorController(codeEditorElement) {
        // 改良されたコントローラー取得方法
        const attempts = [
            () => window.Stimulus?.application?.getControllerForElementAndIdentifier?.(codeEditorElement, 'code-editor'),
            () => codeEditorElement.stimulus?.['code-editor'],
            () => codeEditorElement.codeEditor,
            () => {
                // データ属性を使った直接検索
                const controllerId = codeEditorElement.getAttribute('data-controller');
                if (controllerId && controllerId.includes('code-editor')) {
                    return Object.values(codeEditorElement).find(prop =>
                        prop && typeof prop === 'object' && prop.insertText
                    );
                }
            },
            () => {
                // DOM内の全Stimulusコントローラーから検索
                if (window.Stimulus?.application?.controllers) {
                    return window.Stimulus.application.controllers.find(c =>
                        c.identifier === 'code-editor' && c.element === codeEditorElement
                    );
                }
            }
        ];

        for (const attempt of attempts) {
            try {
                const controller = attempt();
                if (controller && typeof controller.insertText === 'function') {
                    return controller;
                }
            } catch (error) {
                console.warn('Controller access attempt failed:', error);
            }
        }

        return null;
    }

    function showError(message) {
        console.error(message);
        showAlert(message, 'danger');
    }

    function showSuccess(message) {
        console.log(message);
        showAlert(message, 'success');
    }

    function showAlert(message, type) {
        // Create or update alert element
        let alertContainer = document.getElementById('dynamicAlerts');
        if (!alertContainer) {
            alertContainer = document.createElement('div');
            alertContainer.id = 'dynamicAlerts';
            alertContainer.className = 'position-fixed top-0 start-50 translate-middle-x';
            alertContainer.style.zIndex = '1060';
            alertContainer.style.marginTop = '20px';
            document.body.appendChild(alertContainer);
        }

        const alertElement = document.createElement('div');
        alertElement.className = `alert alert-${type} alert-dismissible fade show`;
        alertElement.innerHTML = `
    <i class="fas ${type === 'success' ? 'fa-check-circle' : 'fa-exclamation-circle'} me-2"></i>
    ${message}
    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
  `;

        alertContainer.appendChild(alertElement);

        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (alertElement.parentNode) {
                alertElement.remove();
            }
        }, 5000);
    }

    // 更新進捗モーダル管理
    function initializeUpdateProgressModal() {
        console.log('Initializing update progress modal...');

        const form = document.querySelector('form[data-turbo="false"]');
        const submitBtn = document.getElementById('updateSubmitBtn');
        const progressModal = document.getElementById('updateProgressModal');

        console.log('Elements found:', {
            form: !!form,
            submitBtn: !!submitBtn,
            progressModal: !!progressModal,
            bootstrap: typeof bootstrap !== 'undefined'
        });

        if (form && submitBtn && progressModal) {
            // Bootstrap 5の確認
            if (typeof bootstrap === 'undefined') {
                console.error('Bootstrap is not loaded. Modal will not work.');
                return;
            }

            // 既存のイベントリスナーを削除
            submitBtn.removeEventListener('click', handleUpdateSubmit);

            // 新しいイベントリスナーを追加
            submitBtn.addEventListener('click', handleUpdateSubmit);
            console.log('Update progress modal initialized successfully');
        } else {
            console.warn('Required elements not found for update progress modal');
        }
    }

    // フォーム送信ハンドラーを修正
    async function handleUpdateSubmit(event) {
        console.log('Update submit button clicked');

        // デフォルトの送信を一時停止
        event.preventDefault();

        const progressModal = document.getElementById('updateProgressModal');
        const form = document.querySelector('form[data-turbo="false"]');

        if (!progressModal || !form) {
            console.error('Required elements not found');
            form?.submit();
            return;
        }

        try {
            // モーダルを表示
            const modal = new bootstrap.Modal(progressModal, {
                backdrop: 'static',
                keyboard: false
            });
            modal.show();

            console.log('Modal shown, starting file upload and form submission');

            // 進捗アニメーション開始
            startUpdateProgress();

            // ファイルアップロードを実行してからフォーム送信
            await uploadFilesToS3();

            // 少し遅延してからフォーム送信
            setTimeout(() => {
                console.log('Submitting form...');
                form.submit();
            }, 100);

        } catch (error) {
            console.error('Error during upload or form submission:', error);
            showUpdateError();
        }
    }

    // 更新進捗アニメーション
    function startUpdateProgress() {
        const progressBar = document.getElementById('updateProgressBar');
        const progressText = document.getElementById('updateProgressText');
        const statusText = document.getElementById('updateStatusText');
        const details = document.getElementById('updateDetails');

        let progress = 0;
        const steps = [
            {progress: 15, status: 'フォームデータを検証中...', detail: 'データの整合性を確認しています'},
            {
                progress: 35,
                status: '画像ファイルをS3にアップロード中...',
                detail: `${window.selectedFiles.length}個のファイルを処理しています`
            },
            {progress: 55, status: 'ファイルアップロード完了', detail: 'S3への保存が完了しました'},
            {progress: 75, status: 'データベースを更新中...', detail: '投稿情報を保存しています'},
            {progress: 90, status: '最終処理中...', detail: 'インデックスを更新しています'},
            {progress: 100, status: '完了', detail: '更新が完了しました'}
        ];

        let currentStep = 0;

        const updateProgress = () => {
            if (currentStep < steps.length) {
                const step = steps[currentStep];

                progressBar.style.width = step.progress + '%';
                progressBar.setAttribute('aria-valuenow', step.progress);
                progressText.textContent = step.progress + '%';

                statusText.textContent = step.status;
                details.textContent = step.detail;

                currentStep++;

                setTimeout(updateProgress, 800);
            }
        };

        setTimeout(updateProgress, 200);
    }

    // フォーム送信完了時の処理
    function handleUpdateComplete(success = true) {
        const progressModal = document.getElementById('updateProgressModal');
        const modal = bootstrap.Modal.getInstance(progressModal);

        if (success) {
            // 成功時は自動的にモーダルを閉じる
            setTimeout(() => {
                modal.hide();
            }, 1000);
        } else {
            // エラー時はエラー表示に変更
            showUpdateError();
        }
    }

    // エラー時の表示変更
    function showUpdateError() {
        // progressModal要素を関数内で取得
        const progressModal = document.getElementById('updateProgressModal');

        const progressBar = document.getElementById('updateProgressBar');
        const progressText = document.getElementById('updateProgressText');
        const statusText = document.getElementById('updateStatusText');
        const details = document.getElementById('updateDetails');
        const modalTitle = document.getElementById('updateProgressModalLabel');

        // エラー表示に変更
        progressBar.className = 'progress-bar bg-danger';
        progressBar.style.width = '100%';
        progressText.textContent = 'エラー';
        statusText.textContent = '更新に失敗しました';
        details.textContent = 'もう一度お試しください';
        modalTitle.innerHTML = '<i class="fas fa-exclamation-triangle me-2"></i>エラーが発生しました';

        // 閉じるボタンを追加
        if (progressModal) {
            const modalBody = progressModal.querySelector('.modal-body');
            const closeButton = document.createElement('button');
            closeButton.className = 'btn btn-secondary mt-3';
            closeButton.textContent = '閉じる';
            closeButton.onclick = () => {
                const modal = bootstrap.Modal.getInstance(progressModal);
                if (modal) {
                    modal.hide();
                }
            };
            modalBody.appendChild(closeButton);
        }
    }

    // Global functions for compatibility
    window.initializeFormFeatures = initializeFormFeatures;
    window.performAutoSave = performAutoSave;

    // Initialize all features when DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
        initializeUpdateProgressModal();
    });

    // 選択されたファイル名を表示する関数（新規追加）
    function displaySelectedFiles(files) {
        const displayArea = document.getElementById('selectedFilesDisplay');
        const filesList = document.getElementById('selectedFilesList');

        if (files.length > 0) {
            displayArea.style.display = 'block';
            filesList.innerHTML = '';

            files.forEach((file, index) => {
                const fileItem = document.createElement('div');
                fileItem.className = 'mb-1 d-flex align-items-center justify-content-between';
                fileItem.innerHTML = `
                <span class="small">
                    <i class="fas fa-image text-primary me-1"></i>
                    ${file.name} <span class="text-muted">(${formatFileSize(file.size)})</span>
                </span>
                <button type="button" class="btn btn-sm btn-outline-danger"
                        onclick="removeSelectedFile(${index})" title="削除">
                    <i class="fas fa-times"></i>
                </button>
            `;
                filesList.appendChild(fileItem);
            });
        } else {
            displayArea.style.display = 'none';
        }
    }

    // ファイルサイズをフォーマットする関数（新規追加）
    function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // 選択されたファイルを削除する関数（新規追加）
    function removeSelectedFile(index) {
        window.selectedFiles.splice(index, 1);
        displaySelectedFiles(window.selectedFiles);

        // ファイル入力フィールドをリセット
        const imageInput = document.getElementById('imageInput');
        if (imageInput) {
            const dt = new DataTransfer();
            window.selectedFiles.forEach(file => dt.items.add(file));
            imageInput.files = dt.files;
        }
    }

    // S3にファイルをアップロードする関数（修正版）
    async function uploadFilesToS3() {
        if (window.selectedFiles.length === 0) {
            console.log('No files to upload');
            return;
        }

        console.log('Starting file upload to S3...');

        const uploadPromises = window.selectedFiles.map(async (file) => {
            try {
                // Active Storage Direct Uploadの正しいパラメータ
                const uploadData = {
                    blob: {
                        filename: file.name,
                        content_type: file.type,
                        byte_size: file.size,
                        checksum: await generateChecksum(file) // MD5チェックサムが必要
                    }
                };

                // まず署名付きIDを取得
                const response = await fetch('/rails/active_storage/direct_uploads', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCSRFToken(),
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: JSON.stringify(uploadData)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`Upload preparation failed for ${file.name}:`, errorText);
                    throw new Error(`Upload preparation failed for ${file.name}: ${response.status}`);
                }

                const result = await response.json();

                // 実際のファイルアップロード（S3へ）
                const uploadResponse = await fetch(result.direct_upload.url, {
                    method: 'PUT',
                    body: file,
                    headers: result.direct_upload.headers || {}
                });

                if (!uploadResponse.ok) {
                    throw new Error(`File upload to S3 failed for ${file.name}`);
                }

                console.log(`Upload completed for ${file.name}:`, result);
                return result;

            } catch (error) {
                console.error(`Error uploading ${file.name}:`, error);
                throw error;
            }
        });

        try {
            await Promise.all(uploadPromises);
            console.log('All files uploaded successfully');
        } catch (error) {
            console.error('Error during file upload:', error);
            throw error;
        }
    }

    // MD5チェックサム生成関数
    async function generateChecksum(file) {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = function (e) {
                const wordArray = CryptoJS.lib.WordArray.create(e.target.result);
                const hash = CryptoJS.MD5(wordArray);
                const base64Hash = CryptoJS.enc.Base64.stringify(hash);
                resolve(base64Hash);
            };
            reader.readAsArrayBuffer(file);
        });
    }

    // 高さ測定のユーティリティ
    function elH(selector) {
        const el = typeof selector === 'string' ? document.querySelector(selector) : selector;
        return el ? Math.ceil(el.getBoundingClientRect().height) : 0;
    }

    function adjustContentTextareaHeight() {
        const textarea = document.getElementById('contentTextarea');
        if (!textarea) return;

        // 計測対象
        // 計測対象
        const headerH    = elH('nav.navbar');
        const footerH    = elH('footer');
        const kpLabelH   = elH('label[for="post_key_points"]');
        const kpInputH   = elH('#post_key_points');
        const kpHelpH    = elH('#post_key_points ~ .form-text'); // ← 要点・ポイントの補足テキスト
        const titleLblH  = elH('label[for="post_title"]');
        const titleInpH  = elH('#post_title');
        const contentLblH= elH('label[for="post_content"]');    // ← 内容ラベル（Markdownガイド含む）
        const btnsH      = elH('.post-form-buttons');

        // 余白（Bootstrapの上下マージンやcontainerのパディング等の見込み）
        const safetyPadding = 32; // 24→32 に引き上げ（端末差・フォント差の吸収）

        // ビューポートから差し引き
        const totalMinus = headerH + footerH + kpLabelH + kpInputH + kpHelpH + titleLblH + titleInpH + contentLblH + btnsH + safetyPadding;
        const available  = Math.max(200, Math.floor(window.innerHeight - totalMinus));

        // フッターに隠れないよう、ボタンをフッター分だけ持ち上げる＋フォーム全体に下パディングを確保
        const buttonsEl = document.querySelector('.post-form-buttons');
        if (buttonsEl) {
            buttonsEl.style.position = 'sticky';
            buttonsEl.style.zIndex = '1030';
            buttonsEl.style.bottom = (footerH + 8) + 'px'; // フッター高 + 余白
        }
        const formContainer = document.getElementById('formContainer');
        if (formContainer) {
            // ボタンがフッターに重ならないように、フォーム下に余白を常に確保
            const reserve = footerH + 16; // 少し余裕
            formContainer.style.paddingBottom = reserve + 'px';
        }

        // 通常の textarea に適用
        textarea.style.height = available + 'px';
        textarea.style.minHeight = available + 'px';
        textarea.style.boxSizing = 'border-box';
        textarea.style.overflow = 'auto';

        // CodeMirror があればラッパと scroller にも適用
        const cmWrapper = textarea.nextElementSibling && textarea.nextElementSibling.classList && textarea.nextElementSibling.classList.contains('CodeMirror')
            ? textarea.nextElementSibling
            : null;

        if (cmWrapper) {
            cmWrapper.style.setProperty('height', available + 'px', 'important');
            cmWrapper.style.setProperty('min-height', available + 'px', 'important');
            cmWrapper.style.setProperty('box-sizing', 'border-box');
            cmWrapper.style.setProperty('overflow', 'hidden', 'important');

            // 内部スクローラにも高さを適用（これで中スクロールになる）
            const editor = cmWrapper.CodeMirror;
            if (editor && typeof editor.setSize === 'function') {
                editor.setSize(null, available); // 横幅は自動、縦だけ固定
            }

            // スクロラも !important で固定
            const scroller = cmWrapper.querySelector('.CodeMirror-scroll');
            if (scroller) {
                scroller.style.setProperty('height', available + 'px', 'important');
                scroller.style.setProperty('max-height', available + 'px', 'important');
                scroller.style.setProperty('overflow-y', 'auto', 'important');
            }

            if (cmWrapper.CodeMirror && typeof cmWrapper.CodeMirror.refresh === 'function') {
                cmWrapper.CodeMirror.refresh();
            }
        }

        // --- CodeMirror 6（CM6）対応 ---
        const container = textarea.closest('[data-controller*="code-editor"]') || document;
        const cm6Wrapper = container.querySelector('.cm-editor');
        if (cm6Wrapper) {
            cm6Wrapper.style.setProperty('height', available + 'px', 'important');
            cm6Wrapper.style.setProperty('min-height', available + 'px', 'important');
            cm6Wrapper.style.setProperty('box-sizing', 'border-box');
            cm6Wrapper.style.setProperty('overflow', 'hidden', 'important');

            const scroller6 = cm6Wrapper.querySelector('.cm-scroller');
            if (scroller6) {
                scroller6.style.setProperty('height', available + 'px', 'important');
                scroller6.style.setProperty('max-height', available + 'px', 'important');
                scroller6.style.setProperty('overflow-y', 'auto', 'important');
                scroller6.style.setProperty('overscroll-behavior', 'contain');
            }
        }
    }

    // 初期化とリサイズで反映
    document.addEventListener('DOMContentLoaded', () => {
        adjustContentTextareaHeight();

        // ナビの開閉等で高さが変わる可能性があるため、少し遅延して再計算
        setTimeout(adjustContentTextareaHeight, 100);
        setTimeout(adjustContentTextareaHeight, 300);
    });

    window.addEventListener('resize', () => {
        adjustContentTextareaHeight();
    });

    // Stimulus の code-editor が非同期に立ち上がる場合に備えて
    document.addEventListener('code-editor:initialized', () => {
        adjustContentTextareaHeight();
        setTimeout(adjustContentTextareaHeight, 50);
        setTimeout(adjustContentTextareaHeight, 200);
    });
</script>