<div class="row">
  <div class="col-12">
    <%= form_with model: post, multipart: true, class: "needs-validation",
                  novalidate: true, local: false, data: { turbo: false } do |form| %>
      <!-- 自動保存済み投稿IDを保持する隠しフィールド -->
      <input type="hidden" name="post_id" id="post_id" value="">
      <% if post.errors.any? %>
        <div class="alert alert-danger">
          <h4><%= pluralize(post.errors.count, "error") %> prohibited this post from being saved:</h4>
          <ul>
            <% post.errors.full_messages.each do |message| %>
              <li><%= message %></li>
            <% end %>
          </ul>
        </div>
      <% end %>

      <div class="row" id="formContainer">
        <!-- サイドバー（左側） -->
        <div class="col-md-4" style="height: 100%;">

          <!-- 投稿の目的（投稿タイプの上） -->
          <div class="mb-3">
            <%= form.label :purpose, class: "form-label" do %>
              投稿の目的
              <span class="text-danger">*</span>
              <small class="text-muted">(公開時は必須)</small>
            <% end %>
            <%= form.text_area :purpose, class: "form-control #{'is-invalid' if post.errors[:purpose].any?}", rows: 1,
                               placeholder: "例: ○○○に分かりやすく説明したい" %>
            <div class="form-text">この投稿で何を伝えたいか、具体的な目的を記入してください。</div>
          </div>

          <!-- 投稿タイプ（対象読者の上） -->
          <div class="mb-3">
            <%= form.label :post_type_id, class: "form-label" do %>
              投稿タイプ
              <span class="text-danger">*</span>
              <small class="text-muted">(公開時は必須)</small>
            <% end %>
            <div class="d-flex gap-2 mb-2">
              <%= form.collection_select :post_type_id, PostType.all.order(:name), :id, :display_name,
                                         { prompt: "投稿タイプを選択してください" },
                                         { class: "form-select #{'is-invalid' if post.errors[:post_type_id].any?}", id: "postTypeSelect" } %>
              <button type="button" class="btn btn-outline-primary btn-sm" id="addPostTypeBtn" style="white-space: nowrap;">
                <i class="fas fa-plus"></i> 追加
              </button>
            </div>

            <!-- 新規投稿タイプ追加フォーム（初期は非表示） -->
            <div id="newPostTypeForm" class="card" style="display: none;">
              <div class="card-body p-3">
                <h6 class="card-title">新しい投稿タイプを追加</h6>
                <div class="mb-2">
                  <label for="newPostTypeName" class="form-label form-label-sm">投稿タイプ名</label>
                  <input type="text" id="newPostTypeName" name="newPostTypeName" class="form-control form-control-sm"
                         placeholder="投稿タイプ名" maxlength="50">
                </div>
                <div class="mb-2">
                  <label for="newPostTypeDescription" class="form-label form-label-sm">説明（任意）</label>
                  <textarea id="newPostTypeDescription" class="form-control form-control-sm"
                            placeholder="説明（任意）" rows="2" maxlength="200"></textarea>
                </div>
                <div class="d-flex gap-2">
                  <button type="button" class="btn btn-success btn-sm" id="savePostTypeBtn">
                    <i class="fas fa-save"></i> 保存
                  </button>
                  <button type="button" class="btn btn-secondary btn-sm" id="cancelPostTypeBtn">
                    キャンセル
                  </button>
                </div>
                <div id="postTypeError" class="alert alert-danger mt-2" style="display: none;"></div>
                <div id="postTypeSuccess" class="alert alert-success mt-2" style="display: none;"></div>
              </div>
            </div>
            <div class="form-text">この投稿の主な目的を選択してください。</div>
          </div>

          <!-- カテゴリー選択と新規追加（階層構造対応） -->
          <div class="mb-3">
            <%= form.label :category_id, class: "form-label" do %>
              カテゴリー
              <span class="text-danger">*</span>
              <small class="text-muted">(公開時は必須)</small>
            <% end %>
            <div class="d-flex gap-2 mb-2">
              <%= form.collection_select :category_id, Category.all.order(:name), :id, :full_name,
                                         { prompt: "カテゴリーを選択してください" },
                                         { class: "form-select #{'is-invalid' if post.errors[:category_id].any?}", id: "categorySelect" } %>
              <button type="button" class="btn btn-outline-primary btn-sm" id="addCategoryBtn" style="white-space: nowrap;">
                <i class="fas fa-plus"></i> 追加
              </button>
            </div>

            <!-- 新規カテゴリー追加フォーム（階層構造対応・初期は非表示） -->
            <div id="newCategoryForm" class="card" style="display: none;">
              <div class="card-body p-3">
                <h6 class="card-title">新しいカテゴリーを追加</h6>
                <div class="mb-2">
                  <label for="newCategoryParent" class="form-label form-label-sm">親カテゴリー（任意）</label>
                  <select id="newCategoryParent" class="form-select form-select-sm">
                    <option value="">-- ルートカテゴリーとして作成 --</option>
                    <% Category.all.order(:name).each do |category| %>
                      <option value="<%= category.id %>"><%= category.full_name %></option>
                    <% end %>
                  </select>
                </div>
                <div class="mb-2">
                  <label for="newCategoryName" class="form-label form-label-sm">カテゴリー名</label>
                  <input type="text" id="newCategoryName" name="newCategoryName" class="form-control form-control-sm"
                         placeholder="カテゴリー名" maxlength="50">
                </div>
                <div class="mb-2">
                  <label for="newCategoryDescription" class="form-label form-label-sm">説明（任意）</label>
                  <textarea id="newCategoryDescription" class="form-control form-control-sm"
                            placeholder="説明（任意）" rows="2" maxlength="200"></textarea>
                </div>
                <div class="d-flex gap-2">
                  <button type="button" class="btn btn-success btn-sm" id="saveCategoryBtn">
                    <i class="fas fa-save"></i> 保存
                  </button>
                  <button type="button" class="btn btn-secondary btn-sm" id="cancelCategoryBtn">
                    キャンセル
                  </button>
                </div>
                <div id="categoryError" class="alert alert-danger mt-2" style="display: none;"></div>
                <div id="categorySuccess" class="alert alert-success mt-2" style="display: none;"></div>
              </div>
            </div>
          </div>

          <!-- 対象読者（投稿の目的の下） -->
          <div class="mb-3">
            <%= form.label :target_audience, class: "form-label" do %>
              対象読者
              <span class="text-danger">*</span>
              <small class="text-muted">(公開時は必須)</small>
            <% end %>
            <%= form.text_field :target_audience, class: "form-control #{'is-invalid' if post.errors[:target_audience].any?}", required: true,
                                placeholder: "例: このサイトに訪れた人" %>
            <div class="form-text">どのような読者に向けた内容かを記入してください。</div>
          </div>


          <!-- 期待する成果（対象読者の下） -->
          <div class="mb-3">
            <%= form.label :expected_outcome, "期待する成果", class: "form-label" %>
            <%= form.text_area :expected_outcome, class: "form-control", rows: 1,
                               placeholder: "例: 読者が○○○を知った、理解して欲しい" %>
            <div class="form-text">読者にどうなってほしいかを記入してください。</div>
          </div>


          <!-- 画像アップロード（複数対応） -->
          <div class="mb-3">
            <%= form.label :images, "画像", class: "form-label" %>
            <%= form.file_field :images, multiple: true, accept: "image/*", direct_upload: true,
                                class: "form-control", id: "imageInput" %>
            <div class="form-text">
              複数の画像を選択できます（PNG, JPG, GIF形式）。選択すると、内容欄のカーソル位置に画像のマークダウンを自動で挿入します。
            </div>

            <!-- 既存の画像を表示（編集時のみ） -->
            <% if post.persisted? && post.images.attached? %>
              <div class="mb-3">
                <small class="text-muted d-block mb-2"><br/>現在アップロード済みの画像:</small>
                <div class="row g-2">
                  <% post.images.each_with_index do |image, index| %>
                    <div class="col-6 col-md-4" id="image-card-<%= image.id %>">
                      <div class="card">
                        <%= image_tag image, class: "card-img-top", style: "height: 120px; object-fit: cover;" %>
                        <div class="card-body p-2">
                          <small class="text-muted d-block"><%= image.filename %></small>
                          <div class="d-flex gap-1 mt-1">
                            <button type="button" class="btn btn-outline-primary btn-sm flex-fill insert-existing-image"
                                    data-filename="<%= image.filename %>"
                                    data-url="attachment:<%= image.filename %>">
                              <i class="fas fa-plus"></i> 挿入
                            </button>
                            <button type="button" class="btn btn-outline-danger btn-sm delete-image-btn"
                                    data-post-id="<%= post.id %>"
                                    data-attachment-id="<%= image.id %>"
                                    data-filename="<%= image.filename %>">
                              <i class="fas fa-trash"></i>
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  <% end %>
                </div>
                <small class="text-info d-block mt-2">
                  <i class="fas fa-info-circle"></i>
                  既存の画像は自動的に保持されます。新しい画像を追加する場合のみ下のファイル選択を使用してください。
                </small>
              </div>
            <% end %>

          </div>

          <!-- 動画アップロード（複数対応） -->
          <div class="mb-3">
            <%= form.label :videos, "動画", class: "form-label" %>

            <!-- 既存の動画を表示（編集時のみ） -->
            <% if post.persisted? && post.videos.attached? %>
              <div class="mb-3">
                <small class="text-muted d-block mb-2">現在アップロード済みの動画:</small>
                <div class="row g-2">
                  <% post.videos.each_with_index do |video, index| %>
                    <div class="col-6 col-md-4" id="video-card-<%= video.id %>">
                      <div class="card">
                        <div class="card-body p-2 text-center">
                          <i class="fas fa-video fa-3x text-muted mb-2"></i>
                          <small class="text-muted d-block"><%= video.filename %></small>
                          <div class="d-flex gap-1 mt-1">
                            <button type="button" class="btn btn-outline-primary btn-sm flex-fill insert-existing-video"
                                    data-filename="<%= video.filename %>"
                                    data-url="attachment:<%= video.filename %>">
                              <i class="fas fa-plus"></i> 挿入
                            </button>
                            <button type="button" class="btn btn-outline-danger btn-sm delete-video-btn"
                                    data-post-id="<%= post.id %>"
                                    data-attachment-id="<%= video.id %>"
                                    data-filename="<%= video.filename %>">
                              <i class="fas fa-trash"></i>
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  <% end %>
                </div>
                <small class="text-info d-block mt-2">
                  <i class="fas fa-info-circle"></i>
                  既存の動画は自動的に保持されます。新しい動画を追加する場合のみ下のファイル選択を使用してください。
                </small>
              </div>
            <% end %>

            <%= form.file_field :videos, accept: "video/*", direct_upload: true,
                                class: "form-control", id: "videoInput" %>
            <div class="form-text">
              動画は1つのみ選択できます（MP4, WebM など）。選択すると、内容欄のカーソル位置に動画のプレースホルダを自動で挿入します（プレビューは表示しません）。
            </div>
          </div>
        </div>

        <!-- メインコンテンツ（右側） -->
        <div class="col-md-8 d-flex flex-column" style="height: 100%;">

          <!-- 要点・ポイント（タイトルの上） -->
          <div class="mb-3">
            <%= form.label :key_points, "要点・ポイント", class: "form-label" %>
            <%= form.text_area :key_points, class: "form-control", rows: 4,
                               placeholder: "例：\n1. 環境構築の手順\n2. 基本的なコマンドの使い方\n3. よくあるエラーとその対処法" %>
            <div class="form-text">読者に伝えたい主要なポイントを箇条書きで記入してください。</div>
          </div>

          <!-- タイトル -->
          <div class="mb-3">
            <%= form.label :title, class: "form-label" do %>
              タイトル
              <span class="text-danger">*</span>
              <small class="text-muted">(常に必須)</small>
            <% end %>
            <%= form.text_field :title, class: "form-control #{'is-invalid' if post.errors[:title].any?}", required: true, placeholder: "投稿タイトル" %>
            <div class="invalid-feedback">
              タイトルを入力してください。
            </div>
          </div>

          <!-- 内容 -->
          <div class="mb-3 flex-grow-1 d-flex flex-column">
            <%= form.label :content, class: "form-label" do %>
              内容
              <span class="text-danger">*</span>
              <small class="text-muted">(常に必須)</small>
              <small class="text-muted d-block">
                <%= link_to markdown_guide_path,
                            target: "_blank",
                            class: "text-decoration-none" do %>
                  <i class="fas fa-book me-1"></i>Markdown記法ガイド（日本語）
                <% end %>
              </small>
            <% end %>
            <%= form.text_area :content, class: "form-control flex-grow-1 #{'is-invalid' if post.errors[:content].any?}",
                               id: "contentTextarea", required: true, style: "overflow:auto; resize:vertical; min-height: 400px; font-family: Monaco, 'Lucida Console', monospace;",
                               placeholder: "内容を入力してください", data: Rails.env.test? ? {} : { controller: "code-editor", "code-editor-target": "textarea" } %>
            <div class="invalid-feedback">
              内容を入力してください。
            </div>
          </div>

          <!-- アップロード進捗表示 -->
          <div id="uploadProgressContainer" class="mb-3" style="display: none;">
            <div class="alert alert-info mb-2">
              <i class="fas fa-cloud-upload-alt me-2"></i>
              <span id="uploadStatusText">アップロード中...</span>
            </div>
            <div class="progress" style="height: 8px;">
              <div id="uploadProgressBar"
                   class="progress-bar progress-bar-striped progress-bar-animated"
                   role="progressbar"
                   style="width: 0%"
                   aria-valuenow="0"
                   aria-valuemin="0"
                   aria-valuemax="100">
              </div>
            </div>
            <div class="mt-2">
              <small class="text-muted" id="uploadDetails">準備中...</small>
            </div>
          </div>

          <!-- 投稿・キャンセル（入力欄の下／2列レイアウト） -->
          <div class="mb-3 sticky-actions">
            <div class="row g-2">
              <div class="col-6">
                <%= form.submit post.persisted? ? "更新" : "投稿",
                                class: "btn btn-primary w-100",
                                name: "commit",
                                id: "submitButton",
                                onclick: "document.getElementById('post_status').value = 'published';" %>
              </div>
              <div class="col-6">
                <%= link_to "キャンセル", posts_path, class: "btn btn-secondary w-100" %>
              </div>
            </div>
            <%= form.hidden_field :status, id: "post_status", value: post.status || "published" %>
          </div>

        </div>
      </div>
    <% end %>
  </div>
</div>

<script>
    // DOMContentLoadedイベント後に確認
    document.addEventListener('DOMContentLoaded', function () {
        // required属性を持つフィールドに背景色を適用
        const requiredFields = document.querySelectorAll('#formContainer [required]');
        requiredFields.forEach(field => {
            if (field.classList.contains('form-control') || field.classList.contains('form-select')) {
                field.style.backgroundColor = '#f7d6e6';
            }
        });

        // アスタリスクマーカーがあるフィールドに背景色を適用
        const asteriskLabels = document.querySelectorAll('#formContainer label .text-danger');
        asteriskLabels.forEach(asterisk => {
            const container = asterisk.closest('.mb-3');
            if (container) {
                const field = container.querySelector('.form-control, .form-select');
                if (field) {
                    field.style.backgroundColor = '#f7d6e6';
                }
            }
        });

        function waitForActiveStorage() {
            return new Promise((resolve) => {
                // 既に利用可能な場合は即座に解決
                if (window.ActiveStorage && typeof window.ActiveStorage.DirectUpload === 'function') {
                    resolve(window.ActiveStorage);
                    return;
                }

                // カスタムイベントを待機
                const handler = (event) => {
                    console.log('ActiveStorage initialization event received');
                    document.removeEventListener('activestorage:initialized', handler);
                    resolve(event.detail.ActiveStorage);
                };

                document.addEventListener('activestorage:initialized', handler);

                // タイムアウト処理（10秒後）
                setTimeout(() => {
                    document.removeEventListener('activestorage:initialized', handler);
                    console.warn('ActiveStorage initialization timeout');
                    resolve(null);
                }, 10000);
            });

        }


        // ActiveStorage確認の実行
        waitForActiveStorage().then((activeStorage) => {
            if (activeStorage) {
                console.log('ActiveStorage confirmed available:', typeof activeStorage);
                console.log('DirectUpload available:', typeof activeStorage.DirectUpload);

                // ステータス表示要素があれば更新
                const statusElement = document.getElementById('activestorage-status');
                if (statusElement) {
                    statusElement.textContent = 'ActiveStorage Ready';
                    statusElement.className = 'badge bg-success';
                }
            } else {
                console.error('ActiveStorage initialization failed or timed out');

                // ステータス表示要素があれば更新
                const statusElement = document.getElementById('activestorage-status');
                if (statusElement) {
                    statusElement.textContent = 'ActiveStorage Failed';
                    statusElement.className = 'badge bg-danger';
                }
            }
        });
    });


    // Rails 8 handles CSRF tokens automatically with form_with

    // JavaScriptコードを即座に実行するように修正
    (function () {
        // CSRFトークンを取得
        function getCSRFToken() {
            const token = document.querySelector('meta[name="csrf-token"]');
            return token ? token.getAttribute('content') : '';
        }


        async function makeAuthenticatedRequest(url, options = {}) {
            const token = getCSRFToken();

            return fetch(url, {
                ...options,
                headers: {
                    ...options.headers,
                    'X-CSRF-Token': token,
                    'Content-Type': 'application/json'
                }
            });
        }

        // カテゴリー管理機能
        function initializeCategoryForm() {
            console.log('Initializing category form...'); // デバッグ用

            // 要素の存在を確認してから初期化
            const checkElements = () => {
                const addCategoryBtn = document.getElementById('addCategoryBtn');
                const newCategoryForm = document.getElementById('newCategoryForm');
                const saveCategoryBtn = document.getElementById('saveCategoryBtn');
                const cancelCategoryBtn = document.getElementById('cancelCategoryBtn');

                console.log('Elements found:', {
                    addCategoryBtn: !!addCategoryBtn,
                    newCategoryForm: !!newCategoryForm,
                    saveCategoryBtn: !!saveCategoryBtn,
                    cancelCategoryBtn: !!cancelCategoryBtn
                });

                // 必要な要素が全て存在する場合のみ初期化
                if (addCategoryBtn && newCategoryForm && saveCategoryBtn && cancelCategoryBtn) {
                    // イベントリスナーの設定
                    setupCategoryFormEvents(addCategoryBtn, newCategoryForm, saveCategoryBtn, cancelCategoryBtn);
                    return true;
                }

                return false;
            };

            // 即座にチェック
            if (!checkElements()) {
                // 少し待ってから再試行
                setTimeout(() => {
                    if (!checkElements()) {
                        console.warn('Category form elements not found after retry');
                    }
                }, 100);
            }
        }

        function setupCategoryFormEvents(addCategoryBtn, newCategoryForm, saveCategoryBtn, cancelCategoryBtn) {
            const categorySelect = document.getElementById('categorySelect');
            const newCategoryName = document.getElementById('newCategoryName');
            const newCategoryDescription = document.getElementById('newCategoryDescription');
            const categoryError = document.getElementById('categoryError');
            const categorySuccess = document.getElementById('categorySuccess');

            // 新しいカテゴリー追加フォームを表示
            addCategoryBtn.addEventListener('click', function (e) {
                e.preventDefault();
                console.log('Add category button clicked'); // デバッグ用

                newCategoryForm.style.display = 'block';
                addCategoryBtn.style.display = 'none';
                newCategoryName.focus();
                hideMessages();
            });

            // カテゴリー追加をキャンセル
            if (cancelCategoryBtn) {
                cancelCategoryBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    newCategoryForm.style.display = 'none';
                    addCategoryBtn.style.display = 'block';
                    clearCategoryForm();
                    hideMessages();
                });
            }

            // 新しいカテゴリーを保存
            if (saveCategoryBtn) {
                saveCategoryBtn.addEventListener('click', async function (e) {
                    e.preventDefault();
                    const name = newCategoryName.value.trim();
                    const description = newCategoryDescription.value.trim();
                    const parentId = document.getElementById('newCategoryParent')?.value || null;

                    if (!name) {
                        showError('カテゴリー名を入力してください。');
                        newCategoryName.focus(); // フォーカスを設定
                        return;
                    }

                    try {
                        saveCategoryBtn.disabled = true;
                        saveCategoryBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 保存中...';

                        const categoryData = {
                            name: name,
                            description: description
                        };

                        if (parentId) {
                            categoryData.parent_id = parseInt(parentId);
                        }

                        const response = await fetch('/categories', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': getCSRFToken(),
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify({
                                category: categoryData
                            })
                        });

                        const data = await response.json();

                        if (data.success) {
                            // メインのカテゴリーセレクトボックスに新しいカテゴリーを追加
                            const displayName = data.category.full_name || data.category.name;
                            const option = new Option(displayName, data.category.id, true, true);
                            categorySelect.add(option);

                            // 親カテゴリー選択肢にも新しいカテゴリーを追加
                            const newCategoryParent = document.getElementById('newCategoryParent');
                            if (newCategoryParent) {
                                const parentOption = new Option(displayName, data.category.id);
                                newCategoryParent.add(parentOption);
                            }

                            showSuccess(data.message);

                            // フォームを隠してリセット
                            setTimeout(() => {
                                newCategoryForm.style.display = 'none';
                                addCategoryBtn.style.display = 'block';
                                clearCategoryForm();
                                hideMessages();
                            }, 2000);
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        showError('カテゴリーの作成中にエラーが発生しました。');
                    } finally {
                        saveCategoryBtn.disabled = false;
                        saveCategoryBtn.innerHTML = '<i class="fas fa-save"></i> 保存';
                    }
                });
            }

            // Enterキーで保存
            if (newCategoryName) {
                newCategoryName.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        saveCategoryBtn.click();
                    }
                });
            }

            function clearCategoryForm() {
                if (newCategoryName) newCategoryName.value = '';
                if (newCategoryDescription) newCategoryDescription.value = '';
                // 親カテゴリーの選択もリセット
                const newCategoryParent = document.getElementById('newCategoryParent');
                if (newCategoryParent) newCategoryParent.value = '';
            }

            function showError(message) {
                if (categoryError) {
                    categoryError.textContent = message;
                    categoryError.style.display = 'block';
                }
                if (categorySuccess) {
                    categorySuccess.style.display = 'none';
                }
            }

            function showSuccess(message) {
                if (categorySuccess) {
                    categorySuccess.textContent = message;
                    categorySuccess.style.display = 'block';
                }
                if (categoryError) {
                    categoryError.style.display = 'none';
                }
            }

            function hideMessages() {
                if (categoryError) categoryError.style.display = 'none';
                if (categorySuccess) categorySuccess.style.display = 'none';
            }
        }

        // DOM読み込み完了時とTurboロード時に初期化
        document.addEventListener('DOMContentLoaded', initializeCategoryForm);
        document.addEventListener('turbo:load', initializeCategoryForm);

        // 投稿タイプフォームの初期化
        function initializePostTypeForm() {
            const addPostTypeBtn = document.getElementById('addPostTypeBtn');
            const newPostTypeForm = document.getElementById('newPostTypeForm');
            const cancelPostTypeBtn = document.getElementById('cancelPostTypeBtn');
            const savePostTypeBtn = document.getElementById('savePostTypeBtn');
            const newPostTypeName = document.getElementById('newPostTypeName');
            const newPostTypeDescription = document.getElementById('newPostTypeDescription');
            const postTypeError = document.getElementById('postTypeError');
            const postTypeSuccess = document.getElementById('postTypeSuccess');
            const postTypeSelect = document.getElementById('postTypeSelect');

            if (!addPostTypeBtn || !newPostTypeForm || !postTypeSelect) return;

            // 「追加」ボタンクリック時
            addPostTypeBtn.addEventListener('click', function (e) {
                e.preventDefault();
                newPostTypeForm.style.display = 'block';
                addPostTypeBtn.style.display = 'none';
                if (newPostTypeName) newPostTypeName.focus();
                hidePostTypeMessages();
            });

            // 「キャンセル」ボタンクリック時
            if (cancelPostTypeBtn) {
                cancelPostTypeBtn.addEventListener('click', function (e) {
                    e.preventDefault();
                    newPostTypeForm.style.display = 'none';
                    addPostTypeBtn.style.display = 'block';
                    clearPostTypeForm();
                    hidePostTypeMessages();
                });
            }

            // 「保存」ボタンクリック時
            if (savePostTypeBtn) {
                savePostTypeBtn.addEventListener('click', async function (e) {
                    e.preventDefault();
                    hidePostTypeMessages();

                    const name = newPostTypeName?.value?.trim();
                    const description = newPostTypeDescription?.value?.trim();

                    if (!name) {
                        showPostTypeError('投稿タイプ名を入力してください。');
                        newPostTypeName.focus(); // フォーカスを設定
                        return;
                    }

                    try {
                        savePostTypeBtn.disabled = true;
                        savePostTypeBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> 保存中...';

                        const response = await fetch('/post_types', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-Token': getCSRFToken(),
                                'Accept': 'application/json'
                            },
                            body: JSON.stringify({
                                post_type: {
                                    name: name,
                                    description: description
                                }
                            })
                        });

                        const data = await response.json();

                        if (data.success) {
                            // メインの投稿タイプセレクトボックスに新しい投稿タイプを追加
                            const option = new Option(data.post_type.name, data.post_type.id, true, true);
                            postTypeSelect.add(option);

                            showPostTypeSuccess(data.message);

                            // フォームを隠してリセット
                            setTimeout(() => {
                                newPostTypeForm.style.display = 'none';
                                addPostTypeBtn.style.display = 'block';
                                clearPostTypeForm();
                                hidePostTypeMessages();
                            }, 2000);
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        showPostTypeError('投稿タイプの作成中にエラーが発生しました。');
                    } finally {
                        savePostTypeBtn.disabled = false;
                        savePostTypeBtn.innerHTML = '<i class="fas fa-save"></i> 保存';
                    }
                });
            }

            // Enterキーで保存
            if (newPostTypeName) {
                newPostTypeName.addEventListener('keypress', function (e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        savePostTypeBtn.click();
                    }
                });
            }

            function clearPostTypeForm() {
                if (newPostTypeName) newPostTypeName.value = '';
                if (newPostTypeDescription) newPostTypeDescription.value = '';
            }

            function showPostTypeError(message) {
                if (postTypeError) {
                    postTypeError.textContent = message;
                    postTypeError.style.display = 'block';
                }
                if (postTypeSuccess) {
                    postTypeSuccess.style.display = 'none';
                }
            }

            function showPostTypeSuccess(message) {
                if (postTypeSuccess) {
                    postTypeSuccess.textContent = message;
                    postTypeSuccess.style.display = 'block';
                }
                if (postTypeError) {
                    postTypeError.style.display = 'none';
                }
            }

            function hidePostTypeMessages() {
                if (postTypeError) postTypeError.style.display = 'none';
                if (postTypeSuccess) postTypeSuccess.style.display = 'none';
            }
        }

        // DOM読み込み完了時とTurboロード時に初期化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePostTypeForm);
        } else {
            initializePostTypeForm();
        }

        document.addEventListener('turbo:load', initializePostTypeForm);

        // 既存のコード（フォームとテキストエリアの高さ調整、画像プレビューなど）
        function adjustLayout() {
            const formContainer = document.getElementById('formContainer');
            const textarea = document.getElementById('contentTextarea');

            if (formContainer && textarea) {
                // Let the page scroll naturally; do not fix the container height
                if (formContainer.style.height) formContainer.style.height = '';

                // Fill the viewport vertically (at least), and grow further to fit content
                // Buttons are now directly under the content, so no need to reserve space for a fixed bar or footer
                const minHeight = 260; // px (increase base size)
                textarea.style.height = 'auto';
                const rect = textarea.getBoundingClientRect();
                const extraPadding = 16; // small bottom padding
                const actions = document.querySelector('#formContainer .sticky-actions');
                const actionsHeight = actions ? actions.getBoundingClientRect().height : 0;
                const footer = document.querySelector('footer');
                const footerHeight = footer ? footer.getBoundingClientRect().height : 0;
                const verticalPadding = actionsHeight + footerHeight + extraPadding;
                const availableViewport = Math.max(0, window.innerHeight - rect.top - verticalPadding);
                // Fill the available viewport (without exceeding it), regardless of current content length
                const desiredHeight = Math.min(availableViewport, Math.max(minHeight, availableViewport, textarea.scrollHeight));
                textarea.style.height = desiredHeight + 'px';
                textarea.style.overflow = 'auto';
            }
        }

        function initializeLayout() {
            setTimeout(adjustLayout, 50);
            const textarea = document.getElementById('contentTextarea');
            if (textarea) {
                const autoResize = () => {
                    textarea.style.height = 'auto';
                    const minHeight = 260;
                    const rect = textarea.getBoundingClientRect();
                    const extraPadding = 16;
                    const actions = document.querySelector('#formContainer .sticky-actions');
                    const actionsHeight = actions ? actions.getBoundingClientRect().height : 0;
                    const footer = document.querySelector('footer');
                    const footerHeight = footer ? footer.getBoundingClientRect().height : 0;
                    const verticalPadding = actionsHeight + footerHeight + extraPadding;
                    const availableViewport = Math.max(0, window.innerHeight - rect.top - verticalPadding);
                    // Fill the available viewport while respecting small screens
                    const desiredHeight = Math.min(availableViewport, Math.max(minHeight, availableViewport, textarea.scrollHeight));
                    textarea.style.height = desiredHeight + 'px';
                };
                textarea.addEventListener('input', autoResize);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeLayout);
        } else {
            initializeLayout();
        }

        // Ensure re-initialization after Turbo navigation
        document.addEventListener('turbo:load', initializeLayout);

        window.addEventListener('resize', adjustLayout);

        // テキストエリア（またはCodeMirror）のカーソル位置に文字列を挿入
        function insertAtCursor(textarea, text) {
            if (!textarea) return;

            // CodeMirrorエディターが存在する場合はそちらを使用
            const codeEditorController = textarea.closest('[data-controller*="code-editor"]');
            if (codeEditorController) {
                const controller = Stimulus.controllers.find(c =>
                    c.element === codeEditorController &&
                    c.identifier === 'code-editor'
                );
                if (controller && controller.insertText) {
                    controller.insertText(text);
                    return;
                }
            }

            // フォールバック: 通常のテキストエリア処理
            const start = textarea.selectionStart ?? textarea.value.length;
            const end = textarea.selectionEnd ?? textarea.value.length;
            const before = textarea.value.substring(0, start);
            const after = textarea.value.substring(end);
            textarea.value = before + text + after;
            const newPos = start + text.length;
            textarea.selectionStart = textarea.selectionEnd = newPos;
            textarea.focus();
            // 高さの自動調整があればイベントを発火
            textarea.dispatchEvent(new Event('input'));
        }

        // === 恒久的解決策：画像管理システム完全版 ===

        class ImageManager {
            constructor() {
                this.selectedFiles = [];
                this.initialized = false;
                this.isProcessing = false; // 重複実行防止フラグ
                this.setupEventListeners();
            }

            // 編集モード判定（単一責任）
            isEditMode() {
                const form = document.querySelector('form');
                if (!form) return false;

                const hasEditInAction = form.action.includes('/edit');
                const hasPostIdInAction = /\/posts\/\d+/.test(form.action);
                const hasPostIdElement = document.querySelector('[data-post-id]') !== null;
                const hasExistingImages = document.querySelector('.row.g-2') !== null;

                // デバッグログ追加
                console.log('=== Edit Mode Check ===');
                console.log('Form action:', form.action);
                console.log('Has edit in action:', hasEditInAction);
                console.log('Has post ID in action:', hasPostIdInAction);
                console.log('Has post ID element:', hasPostIdElement);
                console.log('Has existing images:', hasExistingImages);

                // 既存画像の存在だけでは編集モードと判定しない
                const isEdit = hasEditInAction || hasPostIdInAction || hasPostIdElement;
                console.log('Final edit mode result:', isEdit);
                console.log('======================');

                return isEdit;
            }

            // イベントリスナー設定
            setupEventListeners() {
                if (this.initialized) return;

                this.setupImageInput();
                this.setupExistingImageButtons();
                this.setupResetButton();
                this.setupPageResets();

                this.initialized = true;
            }

            // 画像入力の設定
            setupImageInput() {
                const imageInput = document.getElementById('imageInput');
                const content = document.getElementById('contentTextarea');

                if (!imageInput || !content) return;

                // 既存のイベントリスナーを削除してから新しいリスナーを追加
                if (this.imageInputHandler) {
                    imageInput.removeEventListener('change', this.imageInputHandler);
                }

                this.imageInputHandler = (e) => {
                    this.handleImageSelection(e.target.files);
                };

                imageInput.addEventListener('change', this.imageInputHandler);
            }

            // 画像選択処理（統一ロジック）
            handleImageSelection(files) {
                // 重複処理を防止
                if (this.isProcessing) {
                    console.log('=== handleImageSelection Debug ===');
                    console.log('Already processing, skipping...');
                    console.log('===================================');
                    return;
                }

                this.isProcessing = true;

                console.log('=== handleImageSelection Debug ===');
                console.log('Starting image selection processing...');
                console.log('Files received:', files ? files.length : 0);

                if (!files || files.length === 0) {
                    this.clearSelection();
                    this.isProcessing = false;
                    return;
                }

                // 画像ファイルのみフィルタ
                const imageFiles = Array.from(files).filter(f =>
                    f.type && f.type.startsWith('image/')
                );

                console.log('Image files filtered:', imageFiles.length);

                if (imageFiles.length === 0) {
                    this.clearSelection();
                    this.isProcessing = false;
                    return;
                }

                // モードに関係なく選択は置換（シンプル化）
                this.selectedFiles = imageFiles;
                this.updateFileInput();
                this.updatePreview();

                // 新規投稿の場合のみ自動挿入
                if (!this.isEditMode()) {
                    console.log('Not in edit mode, calling autoInsertMarkdown...');
                    this.autoInsertMarkdown();
                } else {
                    this.autoInsertMarkdown();
                    console.log('In edit mode, skipping autoInsertMarkdown');
                }

                // 処理完了後にフラグをリセット
                setTimeout(() => {
                    this.isProcessing = false;
                    console.log('Processing flag reset');
                }, 100);

                console.log('===================================');
            }

            // ファイル入力の更新（信頼性向上）
            updateFileInput() {
                const imageInput = document.getElementById('imageInput');
                if (!imageInput) return;

                try {
                    const dataTransfer = new DataTransfer();
                    this.selectedFiles.forEach(file => {
                        dataTransfer.items.add(file);
                    });
                    imageInput.files = dataTransfer.files;
                } catch (error) {
                    console.warn('File input update failed:', error);
                    // フォールバック：input要素をリセット
                    this.recreateInput();
                }
            }

            // 入力要素の再作成（フォールバック）
            recreateInput() {
                const imageInput = document.getElementById('imageInput');
                if (!imageInput) return;

                const newInput = imageInput.cloneNode(true);
                newInput.value = '';
                imageInput.parentNode.replaceChild(newInput, imageInput);

                // 新しい要素にイベントリスナーを再設定
                setTimeout(() => {
                    this.initialized = false;
                    this.setupImageInput();
                }, 10);
            }

            // 自動Markdown挿入
            autoInsertMarkdown() {
                const content = document.getElementById('contentTextarea');
                if (!content || this.selectedFiles.length === 0) return;

                console.log('=== autoInsertMarkdown Debug ===');
                console.log('Call timestamp:', new Date().toLocaleTimeString());
                console.log('Content length before:', content.value.length);
                console.log('Selected files count:', this.selectedFiles.length);
                console.log('Selected files:', this.selectedFiles.map(f => f.name));

                const parts = this.selectedFiles.map(file =>
                    `![${file.name}](attachment:${file.name})`
                );

                console.log('Generated markdown parts:', parts);

                const prefix = (content.value && !content.value.endsWith('\n')) ? '\n' : '';
                const textToInsert = prefix + parts.join('\n') + '\n';

                console.log('Text to insert:', JSON.stringify(textToInsert));
                console.log('===============================');

                this.insertAtCursor(content, textToInsert);

                console.log('Content length after:', content.value.length);
            }

            // プレビュー表示の更新
            updatePreview() {
                let previewContainer = document.getElementById('imagePreviewContainer');

                if (!previewContainer) {
                    previewContainer = this.createPreviewContainer();
                }

                if (this.selectedFiles.length === 0) {
                    previewContainer.innerHTML = '';
                    return;
                }

                previewContainer.innerHTML = `
                    <div class="alert alert-info">
                        <strong>選択された画像 (${this.selectedFiles.length}件):</strong>
                        <ul class="mb-0 mt-1">
                            ${this.selectedFiles.map(file => `<li>${file.name}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            // プレビューコンテナの作成
            createPreviewContainer() {
                const imageInput = document.getElementById('imageInput');
                const container = document.createElement('div');
                container.id = 'imagePreviewContainer';
                container.className = 'mt-2';
                imageInput.parentNode.insertBefore(container, imageInput.nextSibling);
                return container;
            }

            // 既存画像ボタンの設定
            setupExistingImageButtons() {
                const buttons = document.querySelectorAll('.insert-existing-image');
                const content = document.getElementById('contentTextarea');

                if (!buttons.length || !content) return;

                buttons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.handleExistingImageInsert(btn, content);
                    });
                });
            }

            // 既存画像挿入処理（重複チェック付き）
            handleExistingImageInsert(btn, content) {
                const filename = btn.dataset.filename || 'image';
                const url = btn.dataset.url;

                // 厳密な重複チェック
                if (this.isDuplicateImage(content.value, filename)) {
                    this.showDuplicateNotification(btn);
                    return;
                }

                // 挿入実行
                const md = `![${filename}](${url})`;
                const prefix = (content.value && !content.value.endsWith('\n')) ? '\n' : '';
                this.insertAtCursor(content, prefix + md + '\n');

                this.showInsertSuccess(btn);
            }

            // 重複チェック
            isDuplicateImage(content, filename) {
                const escapedFilename = filename.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
                const pattern = new RegExp(`!\\[.*?\\]\\(attachment:${escapedFilename}\\)`, 'g');
                return pattern.test(content);
            }

            // 重複通知表示
            showDuplicateNotification(btn) {
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> 既に挿入済み';
                btn.classList.add('btn-warning');
                btn.classList.remove('btn-outline-primary');

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.remove('btn-warning');
                    btn.classList.add('btn-outline-primary');
                }, 2000);
            }

            // 成功通知表示
            showInsertSuccess(btn) {
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-check"></i> 挿入完了';
                btn.classList.add('btn-success');
                btn.classList.remove('btn-outline-primary');

                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.remove('btn-success');
                    btn.classList.add('btn-outline-primary');
                }, 1000);
            }

            // リセットボタン設定
            setupResetButton() {
                const imageInput = document.getElementById('imageInput');
                if (!imageInput || document.getElementById('resetImagesBtn')) return;

                const resetButton = document.createElement('button');
                resetButton.type = 'button';
                resetButton.id = 'resetImagesBtn';
                resetButton.className = 'btn btn-outline-warning btn-sm mt-2';
                resetButton.innerHTML = '<i class="fas fa-undo"></i> 選択をリセット';
                resetButton.addEventListener('click', () => this.resetSelection());

                imageInput.parentNode.appendChild(resetButton);
            }

            // 選択リセット
            resetSelection() {
                this.selectedFiles = [];
                const imageInput = document.getElementById('imageInput');
                if (imageInput) imageInput.value = '';
                this.updatePreview();
            }

            // 選択クリア
            clearSelection() {
                this.resetSelection();
            }

            // ページ遷移時のリセット設定
            setupPageResets() {
                document.addEventListener('turbo:before-visit', () => {
                    this.selectedFiles = [];
                    this.initialized = false;
                });

                document.addEventListener('DOMContentLoaded', () => {
                    this.selectedFiles = [];
                });

                document.addEventListener('turbo:load', () => {
                    this.selectedFiles = [];
                    this.initialized = false;
                    this.setupEventListeners();
                });
            }

            // カーソル位置への挿入
            insertAtCursor(textarea, text) {
                if (!textarea) return;

                // 重複挿入防止のための一意性チェック
                const insertId = `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

                console.log('=== insertAtCursor Debug ===');
                console.log('Insert ID:', insertId);
                console.log('Insert timestamp:', new Date().toLocaleTimeString());
                console.log('Text to insert:', JSON.stringify(text));
                console.log('Textarea value length before:', textarea.value.length);

                // 既に同じテキストが最後に挿入されていないかチェック
                const currentValue = textarea.value;
                if (currentValue.endsWith(text.trim())) {
                    console.log('Same text already at the end, skipping insertion');
                    console.log('============================');
                    return;
                }

                // CodeMirrorエディター対応（安全な方法）
                const codeEditorController = textarea.closest('[data-controller*="code-editor"]');
                if (codeEditorController) {
                    console.log('Using CodeMirror editor');

                    try {
                        // より安全な方法でコントローラーを取得
                        const stimulusApp = window.Stimulus || window.application;
                        if (stimulusApp && stimulusApp.getControllerForElementAndIdentifier) {
                            const controller = stimulusApp.getControllerForElementAndIdentifier(codeEditorController, 'code-editor');
                            if (controller && controller.insertText) {
                                console.log('Found CodeMirror controller, calling insertText');

                                // 重複チェック（CodeMirrorエディタから直接値を取得）
                                if (controller.editor && controller.editor.getValue) {
                                    const currentValue = controller.editor.getValue();
                                    if (currentValue.endsWith(text.trim())) {
                                        console.log('Same text already in CodeMirror, skipping insertion');
                                        console.log('============================');
                                        return;
                                    }
                                }

                                controller.insertText(text);
                                console.log('CodeMirror insertText completed');
                                console.log('============================');
                                return;
                            }
                        }

                        // フォールバック: CodeMirrorエディタが直接利用可能な場合
                        if (window.CodeMirror) {
                            const editors = document.querySelectorAll('.CodeMirror');
                            for (let editorEl of editors) {
                                if (editorEl.CodeMirror && codeEditorController.contains(editorEl)) {
                                    const cm = editorEl.CodeMirror;
                                    const doc = cm.getDoc();
                                    const cursor = doc.getCursor();

                                    // 重複チェック
                                    const currentValue = cm.getValue();
                                    if (currentValue.endsWith(text.trim())) {
                                        console.log('Same text already in CodeMirror (fallback), skipping insertion');
                                        console.log('============================');
                                        return;
                                    }

                                    doc.replaceRange(text, cursor);
                                    cm.focus();
                                    console.log('CodeMirror insertion via fallback completed');
                                    console.log('============================');
                                    return;
                                }
                            }
                        }
                    } catch (error) {
                        console.error('CodeMirror integration error:', error);
                        console.log('Falling back to textarea insertion');
                    }
                }

                console.log('Using standard textarea insertion');
                // 通常のテキストエリア処理
                const start = textarea.selectionStart ?? textarea.value.length;
                const end = textarea.selectionEnd ?? textarea.value.length;
                const before = textarea.value.substring(0, start);
                const after = textarea.value.substring(end);
                textarea.value = before + text + after;
                const newPos = start + text.length;
                textarea.selectionStart = textarea.selectionEnd = newPos;
                textarea.focus();
                textarea.dispatchEvent(new Event('input'));

                console.log('Textarea value length after:', textarea.value.length);
                console.log('============================');
            }
        }

        // グローバル変数を削除し、クラスベースに統一
        let imageManager = null;

        // 初期化関数
        function initializeImageSystem() {
            if (!imageManager) {
                imageManager = new ImageManager();
            }
        }

        // 動画処理（既存のまま維持）
        let videoInsertionInitialized = false;

        // 動画選択時の処理（表示用は元のファイル名）
        function initializeVideoInput() {
            if (videoInsertionInitialized) return;
            const videoInput = document.getElementById('videoInput');
            const content = document.getElementById('contentTextarea');
            if (videoInput && content) {
                videoInput.addEventListener('change', function (e) {
                    if (!this.files || this.files.length === 0) return;

                    const first = Array.from(this.files)
                        .find(f => f.type && f.type.startsWith('video/'));
                    if (!first) return;

                    // 元のファイル名をそのまま使用（表示用）
                    const originalName = first.name;
                    if (this.dataset.lastSig === originalName) return;
                    this.dataset.lastSig = originalName;

                    // Markdownには元のファイル名を使用
                    const md = `[動画 ${originalName}](attachment:${originalName})`;
                    const prefix = (content.value && !content.value.endsWith('\n')) ? '\n' : '';
                    imageManager.insertAtCursor(content, prefix + md + '\n');

                    console.log('Video selected - Original filename preserved for display:', originalName);
                });
                videoInsertionInitialized = true;
            }
        }


        // イベントリスナー設定
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initializeImageSystem();
                initializeVideoInput();
            });
        } else {
            initializeImageSystem();
            initializeVideoInput();
        }

        document.addEventListener('turbo:load', () => {
            initializeImageSystem();
            initializeVideoInput();
        });

        document.addEventListener('turbo:before-visit', () => {
            videoInsertionInitialized = false;
        });

        // フォーム送信時のプログレスバー表示機能
        function initializeFormSubmissionProgress() {
            const form = document.querySelector('form');
            const submitButton = document.getElementById('submitButton');
            const progressContainer = document.getElementById('uploadProgressContainer');
            const progressBar = document.getElementById('uploadProgressBar');
            const statusText = document.getElementById('uploadStatusText');
            const uploadDetails = document.getElementById('uploadDetails');

            // 修正後
            form.addEventListener('submit', function (e) {
                // Rails 8のform_withは自動的にCSRFトークンを処理するため
                // 手動での検証は不要。コメントアウトまたは削除
                const tokenInput = form.querySelector('input[name="authenticity_token"]');
                const metaToken = document.querySelector('meta[name="csrf-token"]');

                console.log('=== CSRF Token Debug ===');
                console.log('Form token:', tokenInput ? tokenInput.value.substring(0, 20) + '...' : 'NOT FOUND');
                console.log('Meta token:', metaToken ? metaToken.getAttribute('content').substring(0, 20) + '...' : 'NOT FOUND');
                console.log('Token match:', tokenInput && metaToken && tokenInput.value === metaToken.getAttribute('content'));
                console.log('=======================');

                console.log('Form submission - letting Rails handle CSRF token automatically');
            });

            // Turbo navigation完了時の処理
            document.addEventListener('turbo:load', function () {
                // ページ遷移後はプログレスバーを非表示にする
                if (progressContainer) {
                    progressContainer.style.display = 'none';
                    progressBar.style.width = '0%';
                    progressBar.setAttribute('aria-valuenow', 0);
                    statusText.textContent = 'アップロード中...';
                    uploadDetails.textContent = '準備中...';
                }

                // フォーム要素を有効化
                disableFormElements(false);
            });

            // フォーム送信エラー時の処理
            document.addEventListener('turbo:submit-end', function (event) {
                const {success} = event.detail;

                if (!success) {
                    // エラー時の処理
                    setTimeout(() => {
                        progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
                        progressBar.classList.add('bg-danger');
                        statusText.innerHTML = '<i class="fas fa-exclamation-triangle me-2"></i>エラーが発生しました';
                        uploadDetails.textContent = 'フォームを確認して再送信してください';

                        // 5秒後にプログレスバーを非表示にしてフォームを有効化
                        setTimeout(() => {
                            progressContainer.style.display = 'none';
                            progressBar.classList.remove('bg-danger');
                            progressBar.classList.add('progress-bar-striped', 'progress-bar-animated');
                            progressBar.style.width = '0%';
                            statusText.textContent = 'アップロード中...';
                            uploadDetails.textContent = '準備中...';
                            disableFormElements(false);
                        }, 5000);
                    }, 500);
                }
            });
        }

        // フォーム送信プログレス機能の初期化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeFormSubmissionProgress);
        } else {
            initializeFormSubmissionProgress();
        }

        document.addEventListener('turbo:load', initializeFormSubmissionProgress);

        // 既存動画の「内容に挿入」ボタン初期化
        function initializeExistingVideoButtons() {
            const buttons = document.querySelectorAll('.insert-existing-video');
            const content = document.getElementById('contentTextarea');
            if (!buttons.length || !content) return;
            buttons.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const url = btn.dataset.url;
                    const filename = btn.dataset.filename || 'video';
                    // シンプルにリンク形式で挿入
                    const md = `[動画 ${filename}](${url})`;
                    insertAtCursor(content, (content.value && !content.value.endsWith('\n') ? '\n' : '') + md + '\n');
                });
            });
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeExistingVideoButtons);
        } else {
            initializeExistingVideoButtons();
        }
        document.addEventListener('turbo:load', initializeExistingVideoButtons);

        // フォーム要素の有効/無効化（グローバル関数として定義）
        function disableFormElements(disable) {
            const form = document.querySelector('form[data-turbo="false"]');
            const submitButton = document.getElementById('submitButton');

            if (submitButton) {
                submitButton.disabled = disable;
                if (disable) {
                    submitButton.innerHTML = '<i class="fas fa-cloud-upload-alt me-2"></i>アップロード中...';
                } else {
                    submitButton.innerHTML = form?.querySelector('[name="commit"]')?.value || '投稿';
                }
            }

            // 入力フィールドのみ無効化（ボタンは個別制御）
            const inputs = form?.querySelectorAll('input, textarea, select');
            if (inputs) {
                inputs.forEach(input => {
                    input.disabled = disable;
                });
            }

            // キャンセルボタン以外のボタンを無効化
            const buttons = form?.querySelectorAll('button:not(.btn-secondary)');
            if (buttons) {
                buttons.forEach(button => {
                    if (button !== submitButton) {
                        button.disabled = disable;
                    }
                });
            }
        }

        // グローバル関数として定義
        window.removeImage = function (index) {
            alert('画像削除機能は後で実装します');
        };

        // 自動保存機能（5秒間隔）
        function initializeAutoSave() {
            // 重複初期化の防止
            if (window.autoSaveInterval) {
                clearInterval(window.autoSaveInterval);
                console.log('既存の自動保存間隔をクリアしました');
            }

            let currentPostId = null;
            let lastSaveData = '';

            // 初期投稿IDの確実な取得
            function determineCurrentPostId() {
                // 1. 編集モードのURL確認
                const editMatch = window.location.pathname.match(/\/posts\/([^\/]+)\/edit/);
                if (editMatch) {
                    return editMatch[1];
                }

                // 2. 表示ページのURL確認（編集ボタンから遷移した場合）
                const showMatch = window.location.pathname.match(/\/posts\/([^\/]+)$/);
                if (showMatch && showMatch[1] !== 'new') {
                    return showMatch[1];
                }

                // 3. フォーム内のhidden fieldから取得
                const form = document.querySelector('form[data-turbo="false"]') ||
                    document.querySelector('form');
                if (form) {
                    const hiddenId = form.querySelector('input[name="post[id]"]');
                    if (hiddenId && hiddenId.value) {
                        return hiddenId.value;
                    }
                }

                return null;
            }

            // フォームデータを取得
            function getFormData() {
                // 複数のセレクタでフォームを検索
                let form = document.querySelector('form[data-turbo="false"]') ||
                    document.querySelector('form.needs-validation') ||
                    document.querySelector('form[action*="posts"]') ||
                    document.querySelector('form');

                if (!form) {
                    console.log('フォーム要素が見つかりません');
                    return null;
                }

                const formData = new FormData();

                // 基本フィールドを収集
                const fields = ['title', 'content', 'purpose', 'target_audience', 'key_points', 'expected_outcome'];
                fields.forEach(fieldName => {
                    const field = form.querySelector(`[name="post[${fieldName}]"]`);
                    if (field && field.value.trim()) {
                        formData.append(fieldName, field.value.trim());
                    }
                });

                // セレクトフィールド
                const categorySelect = form.querySelector('[name="post[category_id]"]');
                if (categorySelect && categorySelect.value) {
                    formData.append('category_id', categorySelect.value);
                }

                const postTypeSelect = form.querySelector('[name="post[post_type_id]"]');
                if (postTypeSelect && postTypeSelect.value) {
                    formData.append('post_type_id', postTypeSelect.value);
                }

                // 動画のsigned_idsを追加（自動保存用）
                const videoSignedIdFields = form.querySelectorAll('input[name="post[video_signed_ids][]"]');
                console.log('自動保存: video_signed_ids fields found:', videoSignedIdFields.length);
                if (videoSignedIdFields.length > 0) {
                    videoSignedIdFields.forEach((field, index) => {
                        if (field.value.trim()) {
                            formData.append('video_signed_ids[]', field.value.trim());
                            console.log(`自動保存: Added video_signed_id ${index}:`, field.value.trim());
                        }
                    });
                } else {
                    console.log('自動保存: No video_signed_ids fields found');
                }

                // 現在の投稿IDがあれば追加（重要：これがIDの保持につながる）
                if (currentPostId) {
                    formData.append('id', currentPostId);
                    console.log('自動保存: 投稿ID', currentPostId, 'を送信');
                } else {
                    console.log('自動保存: 新規投稿として処理');
                }

                return formData;
            }

            // 動画アップロード中は自動保存を遅延
            function delayAutoSaveIfVideoUploading() {
                const videoInput = document.getElementById('videoInput');
                const progressContainer = document.getElementById('uploadProgressContainer');
                
                // 動画アップロード中の場合は3秒待つ
                if (progressContainer && progressContainer.style.display !== 'none') {
                    console.log('Video upload in progress, delaying auto-save...');
                    return new Promise(resolve => {
                        setTimeout(resolve, 3000);
                    });
                }
                return Promise.resolve();
            }

            // 自動保存実行
            async function performAutoSave() {
                // 動画アップロード中は遅延
                await delayAutoSaveIfVideoUploading();
                
                const formData = getFormData();
                if (!formData) return;

                // データに変更がない場合はスキップ
                const currentData = Array.from(formData.entries()).sort().toString();
                if (currentData === lastSaveData) return;

                try {
                    const response = await fetch('/posts/auto_save', {
                        method: 'POST',
                        headers: {
                            'X-CSRF-Token': getCSRFToken(),
                            'Accept': 'application/json'
                        },
                        body: formData
                    });

                    const result = await response.json();

                    if (result.success) {
                        // 投稿IDを更新（新規作成の場合のみ）
                        if (!currentPostId && result.post_id) {
                            currentPostId = result.post_id;
                            console.log('自動保存: 新規投稿ID', currentPostId, 'を取得');

                            // **ここに追加**: 隠しフィールドに投稿IDを設定
                            const hiddenIdField = document.getElementById('post_id');
                            if (hiddenIdField) {
                                hiddenIdField.value = currentPostId;
                                console.log('隠しフィールドに投稿ID', currentPostId, 'を設定しました');
                            } else {
                                console.warn('隠しフィールド#post_idが見つかりません');
                            }

                            // URLを更新（新規投稿の場合）
                            if (!window.location.pathname.includes('/edit')) {
                                history.replaceState(null, null, `/posts/${currentPostId}/edit`);
                            }
                        }

                        lastSaveData = currentData;
                        showAutoSaveStatus('自動保存完了', 'success');
                    } else {
                        showAutoSaveStatus('自動保存失敗', 'error');
                    }
                } catch (error) {
                    console.error('Auto-save error:', error);
                    showAutoSaveStatus('自動保存エラー', 'error');
                }
            }

            // 自動保存ステータス表示
            function showAutoSaveStatus(message, type) {
                let statusDiv = document.getElementById('auto-save-status');
                if (!statusDiv) {
                    statusDiv = document.createElement('div');
                    statusDiv.id = 'auto-save-status';
                    statusDiv.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 1000;
                        opacity: 0;
                        transition: opacity 0.3s;
                    `;
                    document.body.appendChild(statusDiv);
                }

                statusDiv.textContent = message + ' ' + new Date().toLocaleTimeString();
                statusDiv.className = type === 'success' ? 'alert alert-success' : 'alert alert-warning';
                statusDiv.style.opacity = '1';

                setTimeout(() => {
                    statusDiv.style.opacity = '0';
                }, 2000);
            }

            // 初期化時に投稿IDを確定
            currentPostId = determineCurrentPostId();
            console.log('自動保存初期化: 投稿ID =', currentPostId || '新規');

            // 5秒間隔で自動保存開始（グローバル変数に保存）
            window.autoSaveInterval = setInterval(performAutoSave, 5000);
            console.log('自動保存を開始しました (ID:', currentPostId, ')');

            // ページ離脱時にクリア
            window.addEventListener('beforeunload', () => {
                if (window.autoSaveInterval) {
                    clearInterval(window.autoSaveInterval);
                    window.autoSaveInterval = null;
                }
            });
        }

        // 自動保存初期化（テスト環境では無効化）- 重複削除版
        <% unless Rails.env.test? %>
        let autoSaveInitialized = false;

        function ensureAutoSaveInit() {
            if (autoSaveInitialized) {
                console.log('自動保存は既に初期化済みです');
                return;
            }

            if (document.querySelector('form[data-turbo="false"]')) {
                initializeAutoSave();
                autoSaveInitialized = true;
                console.log('自動保存機能を初期化しました');
            } else {
                setTimeout(ensureAutoSaveInit, 100);
            }
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', ensureAutoSaveInit);
        } else {
            ensureAutoSaveInit();
        }

        document.addEventListener('turbo:load', () => {
            autoSaveInitialized = false; // Turbo遷移時にリセット
            ensureAutoSaveInit();
        });
        document.addEventListener('turbo:render', () => {
            autoSaveInitialized = false; // Turbo描画時にリセット
            ensureAutoSaveInit();
        });

        // 遅延初期化は削除（重複を避けるため）
        <% end %>

        // 画像削除機能の初期化フラグ
        let imageDeletionInitialized = false;

        // 画像削除機能
        function initializeImageDeletion() {
            if (imageDeletionInitialized) return;

            const deleteButtons = document.querySelectorAll('.delete-image-btn');

            deleteButtons.forEach(button => {
                // 既にイベントリスナーが追加されている場合はスキップ
                if (button.dataset.initialized === 'true') return;

                button.addEventListener('click', function (e) {
                    e.preventDefault();

                    const postId = this.getAttribute('data-post-id');
                    const attachmentId = this.getAttribute('data-attachment-id');
                    const filename = this.getAttribute('data-filename');

                    // 確認ダイアログ
                    if (confirm(`画像「${filename}」を削除しますか？\n\n削除後は元に戻せません。`)) {
                        deleteImage(postId, attachmentId, filename);
                    }
                });

                // フラグを設定して重複を防止
                button.dataset.initialized = 'true';
            });

            imageDeletionInitialized = true;
        }

        async function deleteImage(postId, attachmentId, filename) {
            try {
                const response = await fetch(`/posts/${postId}/delete_image`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCSRFToken(),
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        attachment_id: attachmentId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // 成功時は画像カードを削除
                    const imageCard = document.getElementById(`image-card-${attachmentId}`);
                    if (imageCard) {
                        imageCard.style.opacity = '0.5';
                        imageCard.style.transition = 'opacity 0.3s';

                        setTimeout(() => {
                            imageCard.remove();
                            showImageDeletionMessage(result.message, 'success');
                        }, 300);
                    }
                } else {
                    showImageDeletionMessage(result.message, 'error');
                }
            } catch (error) {
                console.error('Image deletion error:', error);
                showImageDeletionMessage('画像の削除中にエラーが発生しました', 'error');
            }
        }

        function showImageDeletionMessage(message, type) {
            let messageDiv = document.getElementById('image-deletion-message');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'image-deletion-message';
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    padding: 12px 16px;
                    border-radius: 4px;
                    font-size: 14px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s;
                    max-width: 300px;
                `;
                document.body.appendChild(messageDiv);
            }

            messageDiv.textContent = message;
            messageDiv.className = type === 'success' ? 'alert alert-success' : 'alert alert-danger';
            messageDiv.style.opacity = '1';

            setTimeout(() => {
                messageDiv.style.opacity = '0';
            }, 3000);
        }

        // Turbo対応でリセット
        document.addEventListener('turbo:before-visit', function () {
            imageDeletionInitialized = false;
        });

        // 画像削除機能の初期化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeImageDeletion);
        } else {
            initializeImageDeletion();
        }

        document.addEventListener('turbo:load', initializeImageDeletion);

        // 動画削除機能の初期化フラグ
        let videoDeletionInitialized = false;

        // 動画削除機能
        function initializeVideoDeletion() {
            if (videoDeletionInitialized) return;

            const deleteButtons = document.querySelectorAll('.delete-video-btn');

            deleteButtons.forEach(button => {
                // 既にイベントリスナーが追加されている場合はスキップ
                if (button.dataset.initialized === 'true') return;

                button.addEventListener('click', function (e) {
                    e.preventDefault();

                    const postId = this.getAttribute('data-post-id');
                    const attachmentId = this.getAttribute('data-attachment-id');
                    const filename = this.getAttribute('data-filename');

                    // 確認ダイアログ
                    if (confirm(`動画「${filename}」を削除しますか？\n\n削除後は元に戻せません。`)) {
                        deleteVideo(postId, attachmentId, filename);
                    }
                });

                // フラグを設定して重複を防止
                button.dataset.initialized = 'true';
            });

            videoDeletionInitialized = true;
        }

        async function deleteVideo(postId, attachmentId, filename) {
            try {
                const response = await fetch(`/posts/${postId}/delete_video`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-Token': getCSRFToken(),
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        attachment_id: attachmentId
                    })
                });

                const result = await response.json();

                if (result.success) {
                    // 成功時は動画カードを削除
                    const videoCard = document.getElementById(`video-card-${attachmentId}`);
                    if (videoCard) {
                        videoCard.style.opacity = '0.5';
                        videoCard.style.transition = 'opacity 0.3s';

                        setTimeout(() => {
                            videoCard.remove();
                            showVideoDeletionMessage(result.message, 'success');
                        }, 300);
                    }
                } else {
                    showVideoDeletionMessage(result.message, 'error');
                }
            } catch (error) {
                console.error('Video deletion error:', error);
                showVideoDeletionMessage('動画の削除中にエラーが発生しました', 'error');
            }
        }

        function showVideoDeletionMessage(message, type) {
            let messageDiv = document.getElementById('video-deletion-message');
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'video-deletion-message';
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    padding: 12px 16px;
                    border-radius: 4px;
                    font-size: 14px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s;
                    max-width: 300px;
                `;
                document.body.appendChild(messageDiv);
            }

            messageDiv.textContent = message;
            messageDiv.className = type === 'success' ? 'alert alert-success' : 'alert alert-danger';
            messageDiv.style.opacity = '1';

            setTimeout(() => {
                messageDiv.style.opacity = '0';
            }, 3000);
        }

        // Turbo対応でリセット
        document.addEventListener('turbo:before-visit', function () {
            videoDeletionInitialized = false;
        });

        // 動画削除機能の初期化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeVideoDeletion);
        } else {
            initializeVideoDeletion();
        }

        document.addEventListener('turbo:load', initializeVideoDeletion);

        // Direct Upload機能（動画専用）
        function initializeVideoDirectUpload() {
            const videoInput = document.getElementById('videoInput');
            const progressContainer = document.getElementById('uploadProgressContainer');
            const progressBar = document.getElementById('uploadProgressBar');
            const statusText = document.getElementById('uploadStatusText');
            const uploadDetails = document.getElementById('uploadDetails');
            const submitButton = document.getElementById('submitButton');
            const form = document.querySelector('form[data-turbo="false"]');

            if (!videoInput || !progressContainer) return;

            // signed_idを保存するための変数
            let currentSignedId = null;

            // Direct Upload開始時
            videoInput.addEventListener('direct-upload:initialize', function (event) {
                console.log('Direct Upload initialize event triggered', event);
                const {target, detail} = event;
                const {id, file} = detail;

                // signed_idをリセット
                currentSignedId = null;

                // プログレスバーを表示
                progressContainer.style.display = 'block';
                statusText.textContent = 'アップロード準備中...';
                uploadDetails.textContent = `ファイル: ${file.name} (${formatFileSize(file.size)})`;
                progressBar.style.width = '0%';
                progressBar.setAttribute('aria-valuenow', 0);

                console.log('Upload progress container displayed');

                // フォームとボタンを無効化
                disableFormElements(true);
            });

            // Direct Upload進捗更新時
            videoInput.addEventListener('direct-upload:progress', function (event) {
                console.log('Direct Upload progress event triggered', event);
                const {detail} = event;
                const {id, progress} = detail;

                const percent = Math.round(progress);
                console.log('Upload progress:', percent + '%');
                progressBar.style.width = percent + '%';
                progressBar.setAttribute('aria-valuenow', percent);
                statusText.textContent = `アップロード中... ${percent}%`;

                if (percent === 100) {
                    console.log('Upload completed, updating UI');
                    progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
                    progressBar.classList.add('bg-success');
                    statusText.textContent = 'アップロード完了！';
                    uploadDetails.textContent = 'サーバー処理を開始しています...';
                }
            });

            // signed_idをフォームに追加する共通関数
            function addSignedIdToForm(signedId) {
                console.log('=== addSignedIdToForm Debug ===');
                console.log('Input signedId:', signedId, typeof signedId);

                // 有効性チェック強化
                if (!signedId) {
                    console.warn('Empty signed_id provided');
                    return;
                }

                // 数値の場合は処理しない（invalid signed_id）
                if (typeof signedId === 'number' || /^\d+$/.test(signedId.toString())) {
                    console.warn('Invalid signed_id (numeric):', signedId);
                    return;
                }

                // signed_idが文字列で、適切な形式かチェック
                const signedIdStr = signedId.toString();
                if (signedIdStr.length < 10) {
                    console.warn('Invalid signed_id format (too short):', signedIdStr);
                    return;
                }

                // ActiveStorageのsigned_idの典型的なパターンをチェック
                if (!signedIdStr.includes('--') && !signedIdStr.match(/^[A-Za-z0-9_-]+$/)) {
                    console.warn('Invalid signed_id pattern:', signedIdStr);
                    return;
                }

                const form = document.querySelector('form.needs-validation');
                if (!form) {
                    console.error('Form not found');
                    return;
                }

                // 既存のvideo_signed_ids[]フィールドをクリア（同じsigned_idの重複を避ける）
                const existingFields = form.querySelectorAll('input[name="post[video_signed_ids][]"]');
                existingFields.forEach(field => {
                    if (field.value === signedIdStr) {
                        console.log('Removing duplicate signed_id field:', field.value);
                        field.remove();
                    }
                });

                // 新しいsigned_idフィールドを追加
                const hiddenField = document.createElement('input');
                hiddenField.type = 'hidden';
                hiddenField.name = 'post[video_signed_ids][]';
                hiddenField.value = signedIdStr;
                hiddenField.setAttribute('data-debug', 'video-signed-id');
                hiddenField.setAttribute('data-timestamp', Date.now());

                form.appendChild(hiddenField);
                console.log('Added valid signed_id field:', signedIdStr);

                // 確認用ログ
                const totalFields = form.querySelectorAll('input[name="post[video_signed_ids][]"]');
                console.log('Total video_signed_ids fields:', totalFields.length);
            }

            // Direct Upload完了時の処理（Rails 8対応強化版）
            videoInput.addEventListener('direct-upload:end', function(event) {
                console.log('=== Direct Upload End Event (Rails 8 Enhanced) ===');
                console.log('Event detail:', event.detail);
                console.log('Event target:', event.target);
                console.log('Input element:', videoInput);

                const { detail } = event;
                const { id, file } = detail;

                // Rails 8対応のsigned_id取得（複数の方法を試行）
                let signedId = null;

                // 方法1: event.detailから取得
                if (detail.signedId) {
                    signedId = detail.signedId;
                    console.log('Method 1 - Found signed_id in detail.signedId:', signedId);
                } else if (detail.signed_id) {
                    signedId = detail.signed_id;
                    console.log('Method 1 - Found signed_id in detail.signed_id:', signedId);
                }

                // 方法2: event.targetのdataset属性から取得
                if (!signedId && event.target.dataset) {
                    if (event.target.dataset.signedId) {
                        signedId = event.target.dataset.signedId;
                        console.log('Method 2 - Found signed_id in target.dataset.signedId:', signedId);
                    } else if (event.target.dataset.directUploadSignedId) {
                        signedId = event.target.dataset.directUploadSignedId;
                        console.log('Method 2 - Found signed_id in target.dataset.directUploadSignedId:', signedId);
                    }
                }

                // 方法3: input要素のvalue属性から取得（ActiveStorageが設定する場合がある）
                if (!signedId && videoInput.value && videoInput.value.length > 10) {
                    // valueがファイル名でない場合、signed_idの可能性がある
                    if (!videoInput.value.includes('.') && videoInput.value.includes('--')) {
                        signedId = videoInput.value;
                        console.log('Method 3 - Found signed_id in input.value:', signedId);
                    }
                }

                // 方法4: フォーム内のActiveStorageが生成した隠しフィールドを即座に検索
                if (!signedId) {
                    const form = videoInput.closest('form');
                    const hiddenInputs = form.querySelectorAll('input[type="hidden"]');

                    hiddenInputs.forEach(input => {
                        // ActiveStorageの典型的な隠しフィールド名パターン
                        if (input.name && (
                            input.name.includes('videos') ||
                            input.name.includes('signed_id') ||
                            input.name.includes('direct_upload')
                        ) && input.value && input.value.length > 10) {
                            // ファイル名ではなくsigned_idらしい値をチェック
                            if (input.value.includes('--') || input.value.match(/^[A-Za-z0-9+\/]+=*--/)) {
                                signedId = input.value;
                                console.log('Method 4 - Found signed_id in hidden field:', input.name, '=', signedId);
                            }
                        }
                    });
                }

                // 方法5: ActiveStorageの内部状態から取得
                if (!signedId && window.ActiveStorage && window.ActiveStorage.DirectUpload) {
                    try {
                        // 最後のアップロード結果をActiveStorageの内部状態から取得を試行
                        const uploads = window.ActiveStorage.DirectUpload.uploads || [];
                        if (uploads.length > 0) {
                            const lastUpload = uploads[uploads.length - 1];
                            if (lastUpload && lastUpload.signedId) {
                                signedId = lastUpload.signedId;
                                console.log('Method 5 - Found signed_id in ActiveStorage internal state:', signedId);
                            }
                        }
                    } catch (e) {
                        console.log('Method 5 failed:', e);
                    }
                }

                console.log('Final retrieved signed_id:', signedId);

                // signed_idの有効性チェック（より厳密）
                if (signedId && typeof signedId === 'string' && signedId.length > 10) {
                    // ActiveStorageのsigned_idの典型的なパターンをチェック
                    const isValidSignedId = (
                        signedId.includes('--') || // 一般的なパターン
                        signedId.match(/^[A-Za-z0-9+\/]+=*--/) || // Base64エンコードパターン
                        signedId.match(/^[A-Za-z0-9_-]+$/) // URLセーフなパターン
                    );

                    if (isValidSignedId) {
                        console.log('✅ Valid signed_id confirmed:', signedId);

                        // フォームにsigned_idを追加
                        addSignedIdToForm(signedId);

                        // UIの更新
                        const progressContainer = document.getElementById('uploadProgressContainer');
                        const progressBar = document.getElementById('uploadProgressBar');
                        const statusText = document.getElementById('uploadStatusText');
                        const uploadDetails = document.getElementById('uploadDetails');

                        if (progressBar) {
                            progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
                            progressBar.classList.add('bg-success');
                            progressBar.style.width = '100%';
                        }
                        if (statusText) statusText.textContent = 'アップロード完了！';
                        if (uploadDetails) uploadDetails.textContent = 'ファイルの準備が完了しました';

                        // 2秒後にプログレスバーを非表示にしてフォームを有効化
                        setTimeout(() => {
                            if (progressContainer) progressContainer.style.display = 'none';
                            const form = document.querySelector('form.needs-validation');
                            if (form) {
                                const inputs = form.querySelectorAll('input, textarea, select, button');
                                inputs.forEach(input => input.disabled = false);
                            }
                        }, 2000);

                    } else {
                        console.error('❌ Invalid signed_id format:', signedId);
                        signedId = null; // 無効なのでnullにして次のフォールバックへ
                    }
                }

                // 全ての方法が失敗した場合のフォールバック
                if (!signedId) {
                    console.error('❌ All signed_id retrieval methods failed');

                    // 遅延フォールバック（ActiveStorageの処理完了を待つ）
                    setTimeout(() => {
                        tryDelayedSignedIdExtraction(event);
                    }, 1000);
                }
            });

            // 遅延フォールバック：ActiveStorageの処理完了後にsigned_idを探す
            function tryDelayedSignedIdExtraction(originalEvent) {
                console.log('🔄 Attempting delayed signed_id extraction...');

                const form = videoInput.closest('form');
                const input = originalEvent.target;

                // より広範囲の隠しフィールド検索
                const allInputs = form.querySelectorAll('input');
                let foundSignedId = null;

                allInputs.forEach(inputElement => {
                    const value = inputElement.value;
                    const name = inputElement.name || '';

                    // signed_idらしい値の特徴をチェック
                    if (value && value.length > 15) {
                        const hasSignedIdPattern = (
                            value.includes('--') && value.length > 20 || // 典型的なsigned_idパターン
                            (name.includes('video') && value.match(/^[A-Za-z0-9+\/]+=*$/)) || // Base64パターン
                            (name.includes('signed') && value.length > 15) // signed関連フィールド
                        );

                        if (hasSignedIdPattern) {
                            foundSignedId = value;
                            console.log('🎯 Delayed extraction found signed_id in:', name, '=', foundSignedId);
                            return;
                        }
                    }
                });

                if (foundSignedId) {
                    console.log('✅ Delayed signed_id extraction succeeded:', foundSignedId);
                    addSignedIdToForm(foundSignedId);

                    // 成功UI表示
                    const progressContainer = document.getElementById('uploadProgressContainer');
                    const statusText = document.getElementById('uploadStatusText');
                    if (statusText) statusText.textContent = 'アップロード完了！（遅延取得）';

                    setTimeout(() => {
                        if (progressContainer) progressContainer.style.display = 'none';
                        const form = document.querySelector('form.needs-validation');
                        if (form) {
                            const inputs = form.querySelectorAll('input, textarea, select, button');
                            inputs.forEach(input => input.disabled = false);
                        }
                    }, 2000);

                } else {
                    console.error('❌ Complete failure: No signed_id found through any method');

                    // 最終手段：手動でblob情報をサーバーに問い合わせ
                    tryServerSignedIdRetrieval(originalEvent);
                }
            }

// サーバーからsigned_idを取得する最終手段
            function tryServerSignedIdRetrieval(originalEvent) {
                console.log('🆘 Attempting server-side signed_id retrieval...');

                const file = originalEvent.detail.file;
                if (!file) {
                    showFinalUploadError();
                    return;
                }

                // ファイル情報をサーバーに送信してsigned_idを取得
                const formData = new FormData();
                formData.append('filename', file.name);
                formData.append('filesize', file.size);
                formData.append('content_type', file.type);

                fetch('/rails/active_storage/direct_uploads', {
                    method: 'POST',
                    headers: {
                        'X-CSRF-Token': getCSRFToken()
                    },
                    body: formData
                })
                    .then(response => response.json())
                    .then(data => {
                        if (data.signed_id) {
                            console.log('✅ Server retrieval succeeded:', data.signed_id);
                            addSignedIdToForm(data.signed_id);

                            // 成功UI表示
                            const progressContainer = document.getElementById('uploadProgressContainer');
                            const statusText = document.getElementById('uploadStatusText');
                            if (statusText) statusText.textContent = 'アップロード完了！（サーバー取得）';

                            setTimeout(() => {
                                if (progressContainer) progressContainer.style.display = 'none';
                                const form = document.querySelector('form.needs-validation');
                                if (form) {
                                    const inputs = form.querySelectorAll('input, textarea, select, button');
                                    inputs.forEach(input => input.disabled = false);
                                }
                            }, 2000);
                        } else {
                            showFinalUploadError();
                        }
                    })
                    .catch(error => {
                        console.error('Server retrieval failed:', error);
                        showFinalUploadError();
                    });
            }

            function showFinalUploadError() {
                showUploadErrorToast('動画のアップロードでエラーが発生しました。ページを再読み込みして再試行してください。');

                const form = document.querySelector('form.needs-validation');
                if (form) {
                    const inputs = form.querySelectorAll('input, textarea, select, button');
                    inputs.forEach(input => input.disabled = false);
                }

                // プログレスバーをエラー状態に
                const progressContainer = document.getElementById('uploadProgressContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                const statusText = document.getElementById('uploadStatusText');

                if (progressBar) {
                    progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
                    progressBar.classList.add('bg-danger');
                }
                if (statusText) statusText.textContent = 'アップロードエラー';

                setTimeout(() => {
                    if (progressContainer) progressContainer.style.display = 'none';
                }, 5000);
            }

            // フォールバック関数：Blobからsigned_idを抽出
            function tryExtractSignedIdFromBlob(event) {
                console.log('Attempting to extract signed_id from blob...');

                const input = event.target;
                const form = input.closest('form');

                // フォーム内でActiveStorageが追加した隠しフィールドを探す
                setTimeout(() => {
                    const hiddenInputs = form.querySelectorAll('input[type="hidden"]');
                    let foundSignedId = null;

                    hiddenInputs.forEach(input => {
                        if (input.name && input.name.includes('signed_id') && input.value && input.value.length > 10) {
                            foundSignedId = input.value;
                            console.log('Found signed_id in hidden input:', foundSignedId);
                        }
                    });

                    if (foundSignedId) {
                        addSignedIdToForm(foundSignedId);

                        // 成功UI表示
                        const progressContainer = document.getElementById('uploadProgressContainer');
                        const statusText = document.getElementById('uploadStatusText');
                        if (statusText) statusText.textContent = 'アップロード完了！（フォールバック）';

                        setTimeout(() => {
                            if (progressContainer) progressContainer.style.display = 'none';
                            const form = document.querySelector('form.needs-validation');
                            if (form) {
                                const inputs = form.querySelectorAll('input, textarea, select, button');
                                inputs.forEach(input => input.disabled = false);
                            }
                        }, 2000);

                    } else {
                        // 完全な失敗
                        console.error('Failed to retrieve signed_id through any method');
                        showUploadErrorToast('アップロード処理でエラーが発生しました。ページを再読み込みして再試行してください。');

                        const form = document.querySelector('form.needs-validation');
                        if (form) {
                            const inputs = form.querySelectorAll('input, textarea, select, button');
                            inputs.forEach(input => input.disabled = false);
                        }
                    }
                }, 500);
            }

            // ブロブURL処理の修正（Rails 8対応）
            function safeCreateObjectURL(file) {
                try {
                    // Rails 8でのブロブURL生成エラー対策
                    if (!file || !(file instanceof File)) {
                        console.error('Invalid file object for blob URL creation');
                        return null;
                    }

                    const url = URL.createObjectURL(file);
                    console.log('Created blob URL:', url);

                    // ブロブURLの即座の検証
                    fetch(url, { method: 'HEAD' })
                        .then(response => {
                            if (!response.ok) {
                                console.warn('Created blob URL is not accessible:', url);
                                URL.revokeObjectURL(url);
                            }
                        })
                        .catch(error => {
                            console.warn('Blob URL validation failed:', error);
                        });

                    return url;
                } catch (error) {
                    console.error('Failed to create blob URL:', error);
                    return null;
                }
            }

            // ファイル読み込みエラーの改善
            function handleFileReadError(event, filename) {
                console.error('File read error for:', filename);
                console.error('Error event:', event);

                // Rails 8特有のエラーパターンを処理
                const errorMessage = event.error || event.message || 'ファイル読み込みエラー';

                if (errorMessage.includes('access control') || errorMessage.includes('CORS')) {
                    showUploadErrorToast(`CORS設定エラー：ファイル「${filename}」の読み込みに失敗しました。S3の設定を確認してください。`);
                } else if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
                    showUploadErrorToast(`ネットワークエラー：ファイル「${filename}」のアップロードに失敗しました。接続を確認してください。`);
                } else {
                    showUploadErrorToast(`ファイル「${filename}」の処理でエラーが発生しました。ファイル形式やサイズを確認してください。`);
                }
            }

            // Rails 8でのActiveStorage直接アップロード強制初期化
            function forceActiveStorageInitialization() {
                if (window.ActiveStorage && window.ActiveStorage.start) {
                    // 既存の初期化をクリアして再実行
                    delete window.ActiveStorage.started;
                    window.ActiveStorage.start();

                    console.log('ActiveStorage force re-initialized for Rails 8');

                    // 初期化完了イベントを発火
                    const event = new CustomEvent('activestorage:initialized', {
                        detail: {
                            version: 'Rails 8',
                            timestamp: Date.now()
                        }
                    });
                    document.dispatchEvent(event);
                }
            }

            // ページ読み込み完了時に強制初期化
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(forceActiveStorageInitialization, 100);
            });

            // フォールバック機能：Direct Uploadの結果を手動で確認
            function checkDirectUploadResult(event) {
                console.log('Attempting fallback signed_id retrieval...');

                // Active Storage の内部 API を使用して最新の blob を取得
                setTimeout(async () => {
                    try {
                        const response = await fetch('/rails/active_storage/direct_uploads', {
                            method: 'GET',
                            headers: {
                                'X-CSRF-Token': getCSRFToken(),
                                'Accept': 'application/json'
                            }
                        });

                        if (response.ok) {
                            console.log('Successfully retrieved upload status, but manual signed_id retrieval not available');
                        }
                    } catch (e) {
                        console.error('Fallback retrieval failed:', e);
                    }

                    // 最終的な警告表示
                    showUploadErrorToast('動画のアップロードでエラーが発生しました。ページを再読み込みして再試行してください。');
                    disableFormElements(false);
                }, 1000);
            }

            // 統合エラーハンドリングシステム（恒久対応版）
            videoInput.addEventListener('direct-upload:error', function (event) {
                const {detail} = event;
                const {id, error, file} = detail;

                console.error('=== Video Upload Error Analysis ===');
                console.error('Error object:', error);
                console.error('File:', file?.name);
                console.error('Detail:', detail);

                // エラー種別の判定と処理
                const errorAnalysis = analyzeUploadError(error, file);
                console.error('Error analysis:', errorAnalysis);

                // 統合エラー処理
                handleVideoUploadError(errorAnalysis, file, event);
            });

            // エラー分析関数（恒久対応版）
            function analyzeUploadError(error, file) {
                const analysis = {
                    type: 'unknown',
                    isRetryable: false,
                    userMessage: '動画のアップロードでエラーが発生しました',
                    technicalMessage: '',
                    retryDelay: 2000,
                    maxRetries: 3
                };

                // エラーが文字列の場合の処理
                if (typeof error === 'string') {
                    analysis.technicalMessage = error;

                    // Status: 0 エラーの詳細分析
                    const statusMatch = error.match(/Status:\s*(\d+)/);
                    if (statusMatch) {
                        const status = parseInt(statusMatch[1]);
                        console.error('HTTP Status extracted:', status);

                        switch (status) {
                            case 0:
                                analysis.type = 'network_failure';
                                analysis.isRetryable = true;
                                analysis.userMessage = 'ネットワーク接続エラーが発生しました。自動で再試行します...';
                                analysis.retryDelay = 3000;
                                analysis.maxRetries = 5; // Status: 0は特に多めにリトライ
                                break;
                            case 403:
                                analysis.type = 'cors_or_auth';
                                analysis.isRetryable = true;
                                analysis.userMessage = 'アクセス権限エラーです。再試行します...';
                                analysis.maxRetries = 2;
                                break;
                            case 500:
                            case 502:
                            case 503:
                            case 504:
                                analysis.type = 'server_error';
                                analysis.isRetryable = true;
                                analysis.userMessage = 'サーバーエラーが発生しました。再試行します...';
                                analysis.maxRetries = 3;
                                break;
                            default:
                                analysis.type = 'http_error';
                                analysis.userMessage = `サーバーエラー (${status}) が発生しました`;
                                break;
                        }
                    }

                    // ファイルサイズエラーの検出
                    if (error.includes('too large') || error.includes('size')) {
                        analysis.type = 'file_size';
                        analysis.isRetryable = false;
                        analysis.userMessage = 'ファイルサイズが大きすぎます。100MB以下のファイルを選択してください';
                    }

                    // 日本語ファイル名問題の検出
                    if (file && /[^\x00-\x7F]/.test(file.name)) {
                        analysis.type = 'filename_encoding';
                        analysis.isRetryable = true;
                        analysis.userMessage = '日本語ファイル名の処理でエラーが発生しました。再試行します...';
                        analysis.maxRetries = 2;
                    }

                    // CORS エラーの検出
                    if (error.includes('CORS') || error.includes('access control')) {
                        analysis.type = 'cors';
                        analysis.isRetryable = true;
                        analysis.userMessage = 'アクセス制御エラーです。設定を確認して再試行します...';
                        analysis.maxRetries = 2;
                    }

                } else if (error instanceof Error) {
                    // Error オブジェクトの場合
                    analysis.technicalMessage = error.message;
                    analysis.userMessage = 'アップロード処理でエラーが発生しました';
                }

                return analysis;
            }

            // リトライカウンター（ファイル毎に管理）
            const retryCounters = new Map();

            // 統合エラーハンドラー（恒久対応版）
            function handleVideoUploadError(errorAnalysis, file, originalEvent) {
                const fileName = file?.name || 'unknown_file';
                const currentRetries = retryCounters.get(fileName) || 0;

                console.error(`Error handling for ${fileName}: attempt ${currentRetries + 1}`);

                // プログレスバーをエラー状態に更新
                updateProgressBarForError(errorAnalysis.userMessage);

                // リトライ可能で制限内の場合
                if (errorAnalysis.isRetryable && currentRetries < errorAnalysis.maxRetries) {
                    retryCounters.set(fileName, currentRetries + 1);
                    
                    console.log(`Scheduling retry ${currentRetries + 1}/${errorAnalysis.maxRetries} for ${fileName}`);
                    
                    // プログレスバーにリトライメッセージを表示
                    const statusText = document.getElementById('uploadStatusText');
                    const uploadDetails = document.getElementById('uploadDetails');
                    
                    if (statusText) statusText.textContent = errorAnalysis.userMessage;
                    if (uploadDetails) uploadDetails.textContent = `再試行 ${currentRetries + 1}/${errorAnalysis.maxRetries} - ${errorAnalysis.retryDelay/1000}秒後`;

                    // リトライ実行
                    setTimeout(() => {
                        retryVideoUpload(file, originalEvent);
                    }, errorAnalysis.retryDelay);

                } else {
                    // リトライ制限に達した、またはリトライ不可能なエラー
                    retryCounters.delete(fileName);
                    
                    console.error(`Final failure for ${fileName}:`, errorAnalysis.technicalMessage);
                    
                    // 最終エラー処理
                    handleFinalUploadFailure(errorAnalysis, fileName);
                }
            }

            // リトライ実行関数
            function retryVideoUpload(file, originalEvent) {
                console.log('Executing retry for file:', file?.name);

                const videoInput = document.getElementById('videoInput');
                if (!videoInput || !file) {
                    console.error('Cannot retry: video input or file not available');
                    handleFinalUploadFailure({
                        userMessage: 'リトライに失敗しました',
                        technicalMessage: 'Video input or file not available'
                    }, file?.name || 'unknown');
                    return;
                }

                // プログレスバーをリセット
                const progressContainer = document.getElementById('uploadProgressContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                const statusText = document.getElementById('uploadStatusText');
                const uploadDetails = document.getElementById('uploadDetails');

                if (progressBar) {
                    progressBar.classList.remove('bg-danger');
                    progressBar.classList.add('progress-bar-striped', 'progress-bar-animated');
                    progressBar.style.width = '0%';
                }
                if (statusText) statusText.textContent = 'リトライ中...';
                if (uploadDetails) uploadDetails.textContent = 'ファイルを再送信しています...';

                // 新しいファイル選択をシミュレート（Direct Uploadを再トリガー）
                try {
                    // DataTransferを使用してファイルを再設定
                    const dt = new DataTransfer();
                    dt.items.add(file);
                    videoInput.files = dt.files;

                    // changeイベントを発火してDirect Uploadを再開始
                    const changeEvent = new Event('change', { bubbles: true });
                    videoInput.dispatchEvent(changeEvent);

                } catch (error) {
                    console.error('Retry failed:', error);
                    handleFinalUploadFailure({
                        userMessage: 'リトライに失敗しました',
                        technicalMessage: error.message
                    }, file?.name || 'unknown');
                }
            }

            // プログレスバーエラー更新
            function updateProgressBarForError(message) {
                const progressContainer = document.getElementById('uploadProgressContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                const statusText = document.getElementById('uploadStatusText');

                if (progressContainer) progressContainer.style.display = 'block';
                if (progressBar) {
                    progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
                    progressBar.classList.add('bg-warning'); // 警告色（リトライ中）
                    progressBar.style.width = '100%';
                }
                if (statusText) statusText.innerHTML = `<i class="fas fa-exclamation-triangle me-2"></i>${message}`;
            }

            // 最終失敗処理
            function handleFinalUploadFailure(errorAnalysis, fileName) {
                console.error('Final upload failure:', fileName, errorAnalysis);

                // プログレスバーを最終エラー状態に
                const progressContainer = document.getElementById('uploadProgressContainer');
                const progressBar = document.getElementById('uploadProgressBar');
                const statusText = document.getElementById('uploadStatusText');
                const uploadDetails = document.getElementById('uploadDetails');

                if (progressBar) {
                    progressBar.classList.remove('bg-warning', 'progress-bar-striped', 'progress-bar-animated');
                    progressBar.classList.add('bg-danger');
                    progressBar.style.width = '100%';
                }
                if (statusText) statusText.innerHTML = `<i class="fas fa-times-circle me-2"></i>アップロード失敗`;
                if (uploadDetails) uploadDetails.textContent = errorAnalysis.userMessage;

                // ユーザー向けエラートースト
                showUploadErrorToast(`動画「${fileName}」のアップロードに失敗しました。\n${errorAnalysis.userMessage}`);

                // フォームを再有効化
                disableFormElements(false);

                // プログレスバーを10秒後に非表示
                setTimeout(() => {
                    if (progressContainer) progressContainer.style.display = 'none';
                }, 10000);
            }

            // 成功時にリトライカウンターをクリア
            videoInput.addEventListener('direct-upload:end', function(event) {
                const file = event.detail?.file;
                if (file) {
                    retryCounters.delete(file.name);
                    console.log('Upload success, cleared retry counter for:', file.name);
                }
            });

            // ネットワーク状態監視（恒久対応）
            let networkStatus = {
                isOnline: navigator.onLine,
                lastCheck: Date.now()
            };

            function checkNetworkAndRetry() {
                return new Promise((resolve) => {
                    if (!navigator.onLine) {
                        console.warn('Network is offline, waiting for connection...');
                        const offlineMessage = 'ネットワークが切断されています。接続を確認してください...';
                        showUploadErrorToast(offlineMessage);
                        
                        const waitForOnline = () => {
                            if (navigator.onLine) {
                                console.log('Network is back online');
                                resolve(true);
                            } else {
                                setTimeout(waitForOnline, 1000);
                            }
                        };
                        waitForOnline();
                    } else {
                        resolve(true);
                    }
                });
            }

            // ネットワークイベントリスナー
            window.addEventListener('online', () => {
                networkStatus.isOnline = true;
                console.log('Network status: ONLINE');
                
                const errorToast = document.getElementById('upload-error-toast');
                if (errorToast && errorToast.textContent.includes('ネットワークが切断')) {
                    errorToast.remove();
                }
            });

            window.addEventListener('offline', () => {
                networkStatus.isOnline = false;
                console.log('Network status: OFFLINE');
                showUploadErrorToast('ネットワーク接続が切断されました。動画のアップロードが中断される可能性があります。');
            });

            // ファイル事前検証（恒久対応版）
            videoInput.addEventListener('change', function(event) {
                const file = event.target.files[0];
                if (!file) return;

                console.log('File validation for:', file.name);

                // ファイル検証
                const validation = validateVideoFile(file);
                if (!validation.isValid) {
                    showUploadErrorToast(`ファイル「${file.name}」: ${validation.message}`);
                    event.target.value = ''; // ファイル選択をクリア
                    return;
                }

                console.log('File validation passed for:', file.name);
            });

            function validateVideoFile(file) {
                const validation = { isValid: true, message: '' };

                // ファイルサイズチェック（100MB制限）
                const maxSize = 100 * 1024 * 1024; // 100MB
                if (file.size > maxSize) {
                    validation.isValid = false;
                    validation.message = `ファイルサイズが大きすぎます（${formatFileSize(file.size)}）。100MB以下のファイルを選択してください。`;
                    return validation;
                }

                // ファイル形式チェック
                const allowedTypes = ['video/mp4', 'video/webm', 'video/ogg', 'video/avi', 'video/mov', 'video/quicktime'];
                if (!allowedTypes.includes(file.type)) {
                    validation.isValid = false;
                    validation.message = `サポートされていないファイル形式です（${file.type}）。MP4、WebM、OGG形式を使用してください。`;
                    return validation;
                }

                // ファイル名長さチェック
                if (file.name.length > 255) {
                    validation.isValid = false;
                    validation.message = 'ファイル名が長すぎます。255文字以下にしてください。';
                    return validation;
                }

                return validation;
            }

            function formatFileSize(bytes) {
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                if (bytes === 0) return '0 Bytes';
                const i = Math.floor(Math.log(bytes) / Math.log(1024));
                return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
            }

            // エラートースト改良版
            function showUploadErrorToast(message) {
                let errorDiv = document.getElementById('upload-error-toast');
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.id = 'upload-error-toast';
                    errorDiv.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        background: linear-gradient(135deg, #dc3545, #c82333);
                        color: white;
                        padding: 20px;
                        border-radius: 10px;
                        z-index: 10000;
                        max-width: 450px;
                        box-shadow: 0 8px 16px rgba(0,0,0,0.3);
                        border-left: 4px solid #fff;
                        animation: slideInRight 0.5s ease-out;
                    `;
                    document.body.appendChild(errorDiv);

                    // CSS アニメーション追加
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes slideInRight {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                errorDiv.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <div class="fw-bold mb-2">
                                <i class="fas fa-exclamation-triangle me-2"></i>動画アップロードエラー
                            </div>
                            <div style="white-space: pre-line; font-size: 14px;">${message}</div>
                            <div class="mt-3">
                                <button onclick="location.reload()" 
                                        style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 16px; border-radius: 5px; cursor: pointer; margin-right: 10px;">
                                    ページ再読み込み
                                </button>
                                <button onclick="this.closest('#upload-error-toast').remove()" 
                                        style="background: none; border: 1px solid rgba(255,255,255,0.3); color: white; padding: 8px 16px; border-radius: 5px; cursor: pointer;">
                                    閉じる
                                </button>
                            </div>
                        </div>
                    </div>
                `;
                errorDiv.style.display = 'block';
                
                // 15秒後に自動で消す
                setTimeout(() => {
                    if (errorDiv.parentNode) errorDiv.remove();
                }, 15000);
            }


            // ファイルサイズのフォーマット
            function formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // =================================
        // アップロード機能の初期化（重複防止版）
        // =================================
        let uploadSystemInitialized = false;

        function initializeUploadSystem() {
            if (uploadSystemInitialized) {
                console.log('Upload system already initialized, skipping...');
                return;
            }

            console.log('Initializing upload system...');
            uploadSystemInitialized = true;

            // DirectUpload機能の初期化
            initializeVideoDirectUpload();

            // フォーム送信処理の初期化
            initializeFormSubmission();
        }

        // フォームにCSRFトークンが確実に存在することを保証する関数
        function ensureFormHasCSRFToken() {
            let tokenInput = form.querySelector('input[name="authenticity_token"]');
            const currentToken = getCSRFToken();

            if (!currentToken) {
                console.error('CSRF token not available from meta tag');
                return false;
            }

            if (!tokenInput) {
                // CSRFトークンフィールドを動的に追加
                tokenInput = document.createElement('input');
                tokenInput.type = 'hidden';
                tokenInput.name = 'authenticity_token';
                tokenInput.value = currentToken;
                form.appendChild(tokenInput);
                console.log('CSRF token field added to form');
            } else {
                // 既存のトークンを最新のものに更新
                tokenInput.value = currentToken;
                console.log('CSRF token updated in form');
            }

            console.log('CSRF token ensured:', currentToken.substring(0, 20) + '...');
            return true;
        }

        function initializeFormSubmission() {
            const form = document.querySelector('form[data-turbo="false"]');
            const submitButton = document.getElementById('submitButton');
            const progressContainer = document.getElementById('uploadProgressContainer');
            const progressBar = document.getElementById('uploadProgressBar');
            const statusText = document.getElementById('uploadStatusText');
            const uploadDetails = document.getElementById('uploadDetails');

            if (!form) {
                console.warn('Form not found, skipping upload initialization');
                return;
            }

            // 既存のハンドラーを除去
            if (form._customUploadHandler) {
                form.removeEventListener('submit', form._customUploadHandler);
            }

            // 進捗表示・エラー表示関数（恒久対応版）
            function showProgress(percent, message) {
                let container = document.getElementById('uploadProgressContainer');
                if (!container) {
                    console.warn('uploadProgressContainer not found, creating fallback');
                    container = createFallbackProgressContainer();
                }
                
                const progressBar = container.querySelector('#uploadProgressBar') || container.querySelector('.progress-bar');
                const statusText = container.querySelector('#uploadStatusText') || container.querySelector('.status-text');
                
                if (container) container.style.display = 'block';
                if (progressBar) {
                    progressBar.style.width = percent + '%';
                    progressBar.setAttribute('aria-valuenow', percent);
                }
                if (statusText) statusText.textContent = message;
            }

            function hideProgress() {
                const container = document.getElementById('uploadProgressContainer');
                if (container) {
                    container.style.display = 'none';
                }
            }

            function showUploadError(message) {
                console.error('Upload Error:', message);
                
                // アラートの代わりにトーストスタイルのエラー表示
                let errorDiv = document.getElementById('upload-error-toast');
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.id = 'upload-error-toast';
                    errorDiv.style.cssText = `
                        position: fixed;
                        top: 20px;
                        right: 20px;
                        background: #dc3545;
                        color: white;
                        padding: 15px;
                        border-radius: 5px;
                        z-index: 10000;
                        max-width: 400px;
                        box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                    `;
                    document.body.appendChild(errorDiv);
                }
                
                errorDiv.innerHTML = `
                    <div class="d-flex justify-content-between align-items-start">
                        <div>
                            <strong>アップロードエラー</strong><br>
                            <small>${message}</small>
                        </div>
                        <button onclick="this.parentElement.parentElement.remove()" 
                                style="background:none;border:none;color:white;font-size:18px;cursor:pointer;">×</button>
                    </div>
                `;
                errorDiv.style.display = 'block';
                
                // 10秒後に自動で消す
                setTimeout(() => {
                    if (errorDiv.parentNode) errorDiv.remove();
                }, 10000);
            }

            // フォールバック用の進捗コンテナ作成
            function createFallbackProgressContainer() {
                const container = document.createElement('div');
                container.id = 'uploadProgressContainer';
                container.className = 'mb-3';
                container.style.display = 'none';
                container.innerHTML = `
                    <div class="alert alert-info mb-2">
                        <i class="fas fa-cloud-upload-alt me-2"></i>
                        <span class="status-text">アップロード中...</span>
                    </div>
                    <div class="progress" style="height: 8px;">
                        <div class="progress-bar progress-bar-striped progress-bar-animated"
                             role="progressbar"
                             style="width: 0%"
                             aria-valuenow="0"
                             aria-valuemin="0"
                             aria-valuemax="100">
                        </div>
                    </div>
                `;
                
                // フォームの上部に挿入
                const form = document.querySelector('form.needs-validation');
                if (form) {
                    form.insertBefore(container, form.firstChild);
                } else {
                    document.body.appendChild(container);
                }
                
                return container;
            }

            // フォーム送信ハンドラ（既存の場所を修正）
            async function submitHandler(event) {
                event.preventDefault();
                console.log('Form submission started');

                const form = event.target;

                // 自動保存された投稿IDを取得
                const postIdField = form.querySelector('#post_id');
                const autoSavedPostId = postIdField ? postIdField.value : null;

                console.log('Auto-saved post ID:', autoSavedPostId);

                // FormDataを作成
                const formData = new FormData(form);

                // 自動保存された投稿IDがある場合、隠しフィールドに設定
                if (autoSavedPostId) {
                    formData.set('post_id', autoSavedPostId);
                    console.log('Setting post_id in FormData:', autoSavedPostId);

                    // 自動保存された投稿の情報を補完するため、サーバーから最新データを取得
                    try {
                        const response = await fetch(`/posts/${autoSavedPostId}/edit`, {
                            method: 'GET',
                            headers: {
                                'X-CSRF-Token': getCSRFToken(),
                                'Accept': 'application/json'
                            }
                        });

                        if (response.ok) {
                            // 空のフィールドについては送信しないようにする
                            const emptyFields = [];

                            // contentが空の場合
                            if (!formData.get('post[content]') || !formData.get('post[content]').trim()) {
                                formData.delete('post[content]');
                                emptyFields.push('content');
                            }

                            // category_idが空の場合
                            if (!formData.get('post[category_id]')) {
                                formData.delete('post[category_id]');
                                emptyFields.push('category_id');
                            }

                            // post_type_idが空の場合
                            if (!formData.get('post[post_type_id]')) {
                                formData.delete('post[post_type_id]');
                                emptyFields.push('post_type_id');
                            }

                            console.log('Excluded empty fields:', emptyFields);
                        }
                    } catch (error) {
                        console.error('Error fetching post data:', error);
                    }
                }

                // 動画のsigned_idsを確認・追加
                const videoSignedIdFields = form.querySelectorAll('input[name="post[video_signed_ids][]"]');
                console.log('Video signed_ids fields found:', videoSignedIdFields.length);

                // 既存のvideo_signed_idsを削除してから再追加
                formData.delete('post[video_signed_ids][]');

                videoSignedIdFields.forEach((field, index) => {
                    if (field.value && field.value.trim()) {
                        formData.append('post[video_signed_ids][]', field.value.trim());
                        console.log(`Added video_signed_id ${index}:`, field.value.trim());
                    }
                });

                // ファイル進捗表示の初期化
                showProgress(0, 'アップロード開始...');

                try {
                    // XMLHttpRequestでアップロード（進捗表示付き）
                    const xhr = new XMLHttpRequest();

                    return new Promise((resolve, reject) => {
                        xhr.upload.addEventListener('progress', (e) => {
                            if (e.lengthComputable) {
                                const percentComplete = (e.loaded / e.total) * 100;
                                showProgress(percentComplete, 'アップロード中...');
                            }
                        });

                        xhr.addEventListener('load', () => {
                            hideProgress();

                            if (xhr.status === 200 || xhr.status === 302) {
                                const responseUrl = xhr.responseURL || xhr.getResponseHeader('Location');
                                if (responseUrl) {
                                    window.location.href = responseUrl;
                                } else {
                                    // リダイレクト先が不明な場合は投稿一覧に移動
                                    window.location.href = '/posts';
                                }

                                resolve();
                            }
                        });

                        xhr.addEventListener('error', () => {
                            hideProgress();
                            showUploadError('ネットワークエラーが発生しました');
                            reject(new Error('Network error'));
                        });

                        xhr.open('POST', form.action);
                        xhr.setRequestHeader('X-CSRF-Token', getCSRFToken());
                        xhr.send(formData);
                    });

                } catch (error) {
                    console.error('Upload error:', error);
                    hideProgress();
                    showUploadError('アップロードに失敗しました: ' + error.message);
                    throw error;
                }
            }

            // 既存投稿IDを取得する関数（2459行目付近）
            function getExistingPostId() {
                // 自動保存で作成された投稿IDを取得
                const hiddenIdField = form.querySelector('input[name="post_id"]');
                if (hiddenIdField && hiddenIdField.value) {
                    console.log('隠しフィールドから投稿ID取得:', hiddenIdField.value);
                    return hiddenIdField.value;
                }

                // URLパラメータから取得（編集の場合）
                const match = window.location.pathname.match(/\/posts\/(.+)\/edit/);
                return match ? match[1] : null;
            }

            // 既存投稿データをフォームに設定する関数
            function populateFormWithExistingData(postId, formData) {
                // 自動保存データから必要な情報をフォームデータに追加
                const titleField = form.querySelector('#post_title');
                const contentField = form.querySelector('#post_content');
                const purposeField = form.querySelector('#post_purpose');
                const targetAudienceField = form.querySelector('#post_target_audience');
                const categoryField = form.querySelector('#post_category_id');
                const postTypeField = form.querySelector('#post_post_type_id');

                if (titleField && titleField.value) {
                    formData.set('post[title]', titleField.value);
                }
                if (contentField && contentField.value) {
                    formData.set('post[content]', contentField.value);
                }
                if (purposeField && purposeField.value) {
                    formData.set('post[purpose]', purposeField.value);
                }
                if (targetAudienceField && targetAudienceField.value) {
                    formData.set('post[target_audience]', targetAudienceField.value);
                }
                if (categoryField && categoryField.value) {
                    formData.set('post[category_id]', categoryField.value);
                }
                if (postTypeField && postTypeField.value) {
                    formData.set('post[post_type_id]', postTypeField.value);
                }
            }


            // ファイルサイズフォーマット関数
            function formatBytes(bytes, decimals = 2) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const dm = decimals < 0 ? 0 : decimals;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
            }

            form._customUploadHandler = submitHandler;
            form.addEventListener('submit', submitHandler);
            console.log('Form submission handler registered with integrated progress');
        }

        // Turbo対応の初期化
        function safeInitializeWithTurbo() {
            // 前回の初期化をリセット
            uploadSystemInitialized = false;

            // 新しく初期化
            initializeUploadSystem();
        }

        // イベントリスナーの登録
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeUploadSystem);
        } else {
            initializeUploadSystem();
        }

        document.addEventListener('turbo:load', safeInitializeWithTurbo);
        document.addEventListener('turbo:before-cache', () => {
            uploadSystemInitialized = false;
        });

        // グローバルスコープに必要な関数を公開（デバッグ・手動実行用）
        window.initializeAutoSave = initializeAutoSave;
        window.getCSRFToken = getCSRFToken;

        // 自動保存機能の診断用関数
        window.diagnoseAutoSave = function () {
            console.log('=== 自動保存診断 ===');
            console.log('環境:', '<%= Rails.env %>');

            // フォーム要素の検出
            const selectors = [
                'form[data-turbo="false"]',
                'form.needs-validation',
                'form[action*="posts"]',
                'form'
            ];

            console.log('利用可能なセレクタ:', selectors);
            console.log('initializeAutoSave関数:', typeof initializeAutoSave);
            console.log('CSRFトークン:', getCSRFToken());
            console.log('現在のURL:', window.location.pathname);
            console.log('================');
        };

        // フォーム送信前の最終確認（_form.html.erbの適切な場所に追加）
        document.addEventListener('DOMContentLoaded', function () {
            const form = document.querySelector('form');
            if (form) {
                form.addEventListener('submit', function (event) {
                    console.log('=== Form Submission Debug ===');
                    const videoSignedIds = form.querySelectorAll('input[name="post[video_signed_ids][]"]');
                    console.log('Video signed_ids fields at submission:', videoSignedIds.length);
                    videoSignedIds.forEach((field, index) => {
                        console.log(`  Field ${index}:`, field.value);
                    });

                    // FormDataを確認
                    const formData = new FormData(form);
                    const signedIds = formData.getAll('post[video_signed_ids][]');
                    console.log('FormData video_signed_ids:', signedIds);

                    if (signedIds.length === 0) {
                        console.error('WARNING: No video signed_ids in form data!');
                    }
                });
            }
        });

        // トースト形式のエラー表示（関数依存を排除）
        function showUploadErrorToast(message) {
            let errorToast = document.getElementById('upload-error-toast');
            if (!errorToast) {
                errorToast = document.createElement('div');
                errorToast.id = 'upload-error-toast';
                errorToast.style.cssText = `
            position: fixed;
            top: 20px;
            right: 20px;
            background: #dc3545;
            color: white;
            padding: 15px;
            border-radius: 5px;
            z-index: 10000;
            max-width: 400px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            font-size: 14px;
        `;
                document.body.appendChild(errorToast);
            }

            errorToast.innerHTML = `
        <div class="d-flex justify-content-between align-items-start">
            <div>
                <strong>アップロードエラー</strong><br>
                <small>${message}</small>
            </div>
            <button onclick="this.parentElement.parentElement.remove()"
                    style="background:none;border:none;color:white;font-size:18px;cursor:pointer;margin-left:10px;">×</button>
        </div>
    `;
            errorToast.style.display = 'block';

            // 10秒後に自動で消す
            setTimeout(() => {
                if (errorToast.parentNode) errorToast.remove();
            }, 10000);
        }

        // エラーハンドラーの修正
        videoInput.addEventListener('direct-upload:error', function (event) {
            const { detail } = event;
            const { id, error } = detail;

            console.error('=== Enhanced Error Analysis ===');
            console.error('Error is a string:', error);

            // エラー時のUI復旧処理（関数依存なし）
            const progressContainer = document.getElementById('uploadProgressContainer');
            const progressBar = progressContainer?.querySelector('#uploadProgressBar');
            const statusText = progressContainer?.querySelector('#uploadStatusText');

            if (progressContainer) {
                progressContainer.style.display = 'block';
                if (progressBar) {
                    progressBar.classList.remove('progress-bar-striped', 'progress-bar-animated');
                    progressBar.classList.add('bg-danger');
                    progressBar.style.width = '100%';
                }
                if (statusText) {
                    statusText.innerHTML = '<i class="fas fa-exclamation-triangle me-2"></i>アップロードエラー';
                }
            }

            // エラーメッセージの表示
            showUploadErrorToast('動画のアップロードでエラーが発生しました。ページを再読み込みして再試行してください。');

            // フォーム要素を有効化
            const form = document.querySelector('form.needs-validation');
            if (form) {
                const inputs = form.querySelectorAll('input, textarea, select, button');
                inputs.forEach(input => input.disabled = false);
            }

            // 3秒後にプログレスバーを非表示
            setTimeout(() => {
                if (progressContainer) progressContainer.style.display = 'none';
            }, 3000);
        });

        // フォーム送信成功時の処理
        document.addEventListener('ajax:success', function(event) {
            const response = event.detail[0];
            if (response.success) {
                // 成功メッセージを表示
                const alertDiv = document.createElement('div');
                alertDiv.className = 'alert alert-success alert-dismissible fade show';
                alertDiv.innerHTML = `
      ${response.message}
      <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
    `;

                // フォームの上部に挿入
                const formContainer = document.getElementById('formContainer');
                formContainer.insertBefore(alertDiv, formContainer.firstChild);

                // 5秒後に自動で消す
                setTimeout(() => {
                    if (alertDiv.parentNode) {
                        alertDiv.remove();
                    }
                }, 5000);
            }
        });

        // フォーム送信エラー時の処理
        document.addEventListener('ajax:error', function(event) {
            const response = event.detail[0];
            console.error('更新エラー:', response);

            // エラーメッセージを表示
            const alertDiv = document.createElement('div');
            alertDiv.className = 'alert alert-danger alert-dismissible fade show';
            alertDiv.innerHTML = `
    更新中にエラーが発生しました。
    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
  `;

            const formContainer = document.getElementById('formContainer');
            formContainer.insertBefore(alertDiv, formContainer.firstChild);
        });

        // ファイル読み込み処理の改善（readNextChunkエラー対策）
        function safeCreateObjectURL(file) {
            try {
                const url = URL.createObjectURL(file);
                console.log('Created blob URL:', url);
                return url;
            } catch (error) {
                console.error('Failed to create blob URL:', error);
                return null;
            }
        }

        // ファイル読み込みエラーの改善
        function handleFileReadError(event, filename) {
            console.error('File read error for:', filename);
            console.error('Error event:', event);

            // エラー詳細をユーザーに表示
            showUploadErrorToast(`ファイル「${filename}」の読み込みでエラーが発生しました。ファイル形式や文字エンコーディングを確認してください。`);
        }

    })();
</script>